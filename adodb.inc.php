<?php
/*
 * Set tabs to 4 for best viewing.
 *
 * Latest version is available at http://adodb.org/
 *
 * This is the main include file for ADOdb.
 * Database specific drivers are stored in the adodb/drivers/adodb-*.inc.php
 *
 * The ADOdb files are formatted so that doxygen can be used to generate documentation.
 * Doxygen is a documentation generation tool and can be downloaded from http://doxygen.org/
 */

/**
	\mainpage

	@version   v5.21.0-dev  ??-???-2016
	@copyright (c) 2000-2013 John Lim (jlim#natsoft.com). All rights reserved.
	@copyright (c) 2014      Damien Regad, Mark Newnham and the ADOdb community

	Released under both BSD license and Lesser GPL library license. You can choose which license
	you prefer.

	PHP's database access functions are not standardised. This creates a need for a database
	class library to hide the differences between the different database API's (encapsulate
	the differences) so we can easily switch databases.

	We currently support MySQL, Oracle, Microsoft SQL Server, Sybase, Sybase SQL Anywhere, DB2,
	Informix, PostgreSQL, FrontBase, Interbase (Firebird and Borland variants), Foxpro, Access,
	ADO, SAP DB, SQLite and ODBC. We have had successful reports of connecting to Progress and
	other databases via ODBC.
 */

if (!defined('_ADODB_LAYER')) {
	define('_ADODB_LAYER',1);

	//==============================================================================================
	// CONSTANT DEFINITIONS
	//==============================================================================================


	/**
	 * Set ADODB_DIR to the directory where this file resides...
	 * This constant was formerly called $ADODB_RootPath
	 */
	if (!defined('ADODB_DIR')) {
		define('ADODB_DIR',dirname(__FILE__));
	}

	//==============================================================================================
	// GLOBAL VARIABLES
	//==============================================================================================

	GLOBAL
		$ADODB_vers,		// database version
		$ADODB_COUNTRECS,	// count number of records returned - slows down query
		$ADODB_CACHE_DIR,	// directory to cache recordsets
		$ADODB_CACHE,
		$ADODB_CACHE_CLASS,
		$ADODB_EXTENSION,   // ADODB extension installed
		$ADODB_COMPAT_FETCH, // If $ADODB_COUNTRECS and this is true, $rs->fields is available on EOF
		$ADODB_FETCH_MODE,	// DEFAULT, NUM, ASSOC or BOTH. Default follows native driver default...
		$ADODB_GETONE_EOF,
		$ADODB_QUOTE_FIELDNAMES; // Allows you to force quotes (backticks) around field names in queries generated by getinsertsql and getupdatesql.

	//==============================================================================================
	// GLOBAL SETUP
	//==============================================================================================

	$ADODB_EXTENSION = defined('ADODB_EXTENSION');

	/*********************************************************
	* Controls $ADODB_FORCE_TYPE mode. Default is ADODB_FORCE_VALUE (3).
	* Used in GetUpdateSql and GetInsertSql functions. Thx to Niko, nuko#mbnet.fi
	* @link http://adodb.org/dokuwiki/doku.php?id=v5:reference:adodb_force_type
	*
	* 0 = ignore empty fields. All empty fields in array are ignored.
	* 1 = force null. All empty, php null and string 'null' fields are
	*     changed to sql NULL values.
	* 2 = force empty. All empty, php null and string 'null' fields are
	*     changed to sql empty '' or 0 values.
	* 3 = force value. Value is left as it is. Php null and string 'null'
	*     are set to sql NULL values and empty fields '' are set to empty '' sql values.
	* 4 = force value. Like 1 but numeric empty fields are set to zero.
    */
		define('ADODB_FORCE_IGNORE',0);
		define('ADODB_FORCE_NULL',1);
		define('ADODB_FORCE_EMPTY',2);
		define('ADODB_FORCE_VALUE',3);
		define('ADODB_FORCE_NULL_AND_ZERO',4);
	// ********************************************************


	/**
	 * Constants for returned values from the charMax and textMax methods.
	 * If not specifically defined in the driver, methods return the NOTSET value.
	 */
	define ('ADODB_STRINGMAX_NOTSET', -1);
	define ('ADODB_STRINGMAX_NOLIMIT',-2);

	/*
	* Defines the the default meta type returned
	* when ADOdb encounters a type that it is not
	* defined in the metaTypes.
	*/
	if (!defined('ADODB_DEFAULT_METATYPE'))
		define ('ADODB_DEFAULT_METATYPE','N');

	/**
	 * Associative array case constants
	 *
	 *	The actual values of these constants may and might change in the future. Please use the 
	 *		constants, not the values in your code. All code prior to august/2016 will retain
	 *		backward compatibility even when the constant values are changed in the future.
	 */
	define('ADODB_ASSOC_CASE_LOWER', 0);
	define('ADODB_ASSOC_CASE_UPPER', 1);
	define('ADODB_ASSOC_CASE_NATIVE', 2);

		
	if (!$ADODB_EXTENSION || ADODB_EXTENSION < 4.0) {

		define('ADODB_BAD_RS','<p>Bad $rs in %s. Connection or SQL invalid. Try using $connection->debug=true;</p>');

	// allow [ ] @ ` " and . in table names
		define('ADODB_TABLE_REGEX','([]0-9a-z_\:\"\`\.\@\[-]*)');

	// prefetching used by oracle
		if (!defined('ADODB_PREFETCH_ROWS')) {
			define('ADODB_PREFETCH_ROWS',10);
		}


	/**
	 * Fetch mode
	 *
	 * Set global variable $ADODB_FETCH_MODE to one of these constants or use
	 * the SetFetchMode() method to control how recordset fields are returned
	 * when fetching data. $ADODB_FETCH_MODE controls the default fetch mode
	 * of connection objects, while SetFetchMode() can be used to override
	 * the fetch mode per object.
	 *
	 *   - NUM:     array()
	 *   - ASSOC:   array('id' => 456, 'name' => 'john')
	 *   - BOTH:    array(0 => 456, 'id' => 456, 1 => 'john', 'name' => 'john')
	 *   - DEFAULT: alias for ADODB_FETCH_BOTH. Do not reference within ADODB's
	 *				code. Kept for backward compatibility.
	 */
		define('ADODB_FETCH_DEFAULT', 3);
		define('ADODB_FETCH_NUM', 1);
		define('ADODB_FETCH_ASSOC', 2);
		define('ADODB_FETCH_BOTH', 3);

		if (!defined('TIMESTAMP_FIRST_YEAR')) {
			define('TIMESTAMP_FIRST_YEAR',100);
		}

		/**
		 * AutoExecute constants
		 * (moved from adodb-pear.inc.php since they are only used in here)
		 */
		define('DB_AUTOQUERY_INSERT', 1);
		define('DB_AUTOQUERY_UPDATE', 2);


		// PHP's version scheme makes converting to numbers difficult - workaround
		$_adodb_ver = (float) PHP_VERSION;
		if ($_adodb_ver >= 5.2) {
			define('ADODB_PHPVER',0x5200);
		} else if ($_adodb_ver >= 5.0) {
			define('ADODB_PHPVER',0x5000);
		} else {
			die("PHP5 or later required. You are running ".PHP_VERSION);
		}
		unset($_adodb_ver);
	}


	function ADODB_Setup() {
	GLOBAL
		$ADODB_vers,		// database version
		$ADODB_COUNTRECS,	// count number of records returned - slows down query
		$ADODB_CACHE_DIR,	// directory to cache recordsets
		$ADODB_FETCH_MODE,
		$ADODB_CACHE,
		$ADODB_CACHE_CLASS,
		$ADODB_FORCE_TYPE,
		$ADODB_GETONE_EOF,
		$ADODB_QUOTE_FIELDNAMES;

		if (empty($ADODB_CACHE_CLASS)) {
			$ADODB_CACHE_CLASS =  'ADODB_Cache_File' ;
		}
		$ADODB_FETCH_MODE = ADODB_FETCH_BOTH;
		$ADODB_FORCE_TYPE = ADODB_FORCE_VALUE;
		$ADODB_GETONE_EOF = null;

		if (!isset($ADODB_CACHE_DIR)) {
			$ADODB_CACHE_DIR = '/tmp'; //(isset($_ENV['TMP'])) ? $_ENV['TMP'] : '/tmp';
		} else {
			// do not accept url based paths, eg. http:/ or ftp:/
			if (strpos($ADODB_CACHE_DIR,'://') !== false) {
				die("Illegal path http:// or ftp://");
			}
		}

		/**
		 * ADODB version as a string.
		 */
		$ADODB_vers = 'v5.21.0-dev  ??-???-2016';

		/**
		 * Determines whether recordset->RecordCount() is used.
		 * Set to false for highest performance -- RecordCount() will always return -1 then
		 * for databases that provide "virtual" recordcounts...
		 */
		if (!isset($ADODB_COUNTRECS)) {
			$ADODB_COUNTRECS = true;
		}
	}


	//==============================================================================================
	// CHANGE NOTHING BELOW UNLESS YOU ARE DESIGNING ADODB
	//==============================================================================================

	ADODB_Setup();

	//==============================================================================================
	// CLASS ADOFieldObject
	//==============================================================================================
	/**
	 * Helper class for FetchFields -- holds info on a column
	 */
	class ADOFieldObject {
		public  $name = '';
		public  $max_length=0;
		public  $type=""; //a value understandable by ADORecordSet::MetaType()

		//Temporary method untill drivers explicitly and correctly create the ADOFieldObject objects.
		public function FillFromObject($pObject)
		{
			if(!$pObject)
				{return;}

			foreach(get_object_vars($pObject) as $tKey => $tValue)
				{$this->$tKey = $tValue;}
		}
/*
		// additional fields by dannym... (danny_milo@yahoo.com)
		public  $not_null = false;
		// actually, this has already been built-in in the postgres, fbsql AND mysql module? ^-^
		// so we can as well make not_null standard (leaving it at "false" does not harm anyways)

		public  $has_default = false; // this one I have done only in mysql and postgres for now ...
			// others to come (dannym)
		public  $default_value; // default, if any, and supported. Check has_default first.
*/
	}


	function _adodb_safedate($s) {
		return str_replace(array("'", '\\'), '', $s);
	}

	// parse date string to prevent injection attack
	// date string will have one quote at beginning e.g. '3434343'
	function _adodb_safedateq($s) {
		$len = strlen($s);
		if ($s[0] !== "'") {
			$s2 = "'".$s[0];
		} else {
			$s2 = "'";
		}
		for($i=1; $i<$len; $i++) {
			$ch = $s[$i];
			if ($ch === '\\') {
				$s2 .= "'";
				break;
			} elseif ($ch === "'") {
				$s2 .= $ch;
				break;
			}

			$s2 .= $ch;
		}

		return strlen($s2) == 0 ? 'null' : $s2;
	}


	// for transaction handling

	function ADODB_TransMonitor($dbms, $fn, $errno, $errmsg, $p1, $p2, &$thisConnection) {
		//print "Errorno ($fn errno=$errno m=$errmsg) ";
		$thisConnection->_transOK = false;
		if ($thisConnection->_oldRaiseFn) {
			$fn = $thisConnection->_oldRaiseFn;
			$fn($dbms, $fn, $errno, $errmsg, $p1, $p2,$thisConnection);
		}
	}

	//------------------
	// class for caching
	class ADODB_Cache_File {

		public  $createdir = true; // requires creation of temp dirs

		public function __construct() {
			global $ADODB_INCLUDED_CSV;
			if (empty($ADODB_INCLUDED_CSV)) {
				include_once(ADODB_DIR.'/adodb-csvlib.inc.php');
			}
		}

		// write serialised recordset to cache item/file
		public function writecache($filename, $contents,  $debug, $secs2cache) {
			return adodb_write_file($filename, $contents,$debug);
		}

		// load serialised recordset and unserialise it
		public function &readcache($filename, &$err, $secs2cache, $rsClass) {
			$rs = csv2rs($filename,$err,$secs2cache,$rsClass);
			return $rs;
		}

		// flush all items in cache
		public function flushall($debug=false) {
			global $ADODB_CACHE_DIR;

			$rez = false;

			if (strlen($ADODB_CACHE_DIR) > 1) {
				$rez = $this->_dirFlush($ADODB_CACHE_DIR);
				if ($debug) {
					ADOConnection::outp( "flushall: $ADODB_CACHE_DIR<br><pre>\n". $rez."</pre>");
				}
			}
			return $rez;
		}

		// flush one file in cache
		public function flushcache($f, $debug=false) {
			if (!@unlink($f)) {
				if ($debug) {
					ADOConnection::outp( "flushcache: failed for $f");
				}
			}
		}

		public function getdirname($hash) {
			global $ADODB_CACHE_DIR;
			if (!isset($this->notSafeMode)) {
				$this->notSafeMode = !ini_get('safe_mode');
			}
			return ($this->notSafeMode) ? $ADODB_CACHE_DIR.'/'.substr($hash,0,2) : $ADODB_CACHE_DIR;
		}

		// create temp directories
		public function createdir($hash, $debug) {
			global $ADODB_CACHE_PERMS;

			$dir = $this->getdirname($hash);
			if ($this->notSafeMode && !file_exists($dir)) {
				$oldu = umask(0);
				if (!@mkdir($dir, empty($ADODB_CACHE_PERMS) ? 0771 : $ADODB_CACHE_PERMS)) {
					if(!is_dir($dir) && $debug) {
						ADOConnection::outp("Cannot create $dir");
					}
				}
				umask($oldu);
			}

			return $dir;
		}

		/**
		* Private function to erase all of the files and subdirectories in a directory.
		*
		* Just specify the directory, and tell it if you want to delete the directory or just clear it out.
		* Note: $kill_top_level is used internally in the function to flush subdirectories.
		*/
		protected function _dirFlush($dir, $kill_top_level = false) {
			if(!$dh = @opendir($dir)) return;

			while (($obj = readdir($dh))) {
				if($obj=='.' || $obj=='..') continue;
				$f = $dir.'/'.$obj;

				if (strpos($obj,'.cache')) {
					@unlink($f);
				}
				if (is_dir($f)) {
					$this->_dirFlush($f, true);
				}
			}
			if ($kill_top_level === true) {
				@rmdir($dir);
			}
			return true;
		}
	}

	//==============================================================================================
	// CLASS ADOConnection
	//==============================================================================================

	/**
	 * Connection object. For connecting to databases, and executing queries.
	 */
	abstract class ADOConnection {
	//
	// PUBLIC VARS
	//
	public  $dataProvider = 'native';
	public  $databaseType = '';		/// RDBMS currently in use, eg. odbc, mysql, mssql
	public  $database = '';			/// Name of database to be used.
	public  $host = '';				/// The hostname of the database server
	public  $user = '';				/// The username which is used to connect to the database server.
	public  $port = '';				/// The port of the database server
	public  $password = '';			/// Password for the username. For security, we no longer store it.
	public  $debug = false;			/// if set to true will output sql statements
	public  $maxblobsize = 262144;	/// maximum size of blobs or large text fields (262144 = 256K)-- some db's die otherwise like foxpro
	public  $concat_operator = '+'; /// default concat operator -- change to || for Oracle/Interbase. NOTE: Copied from ADODB_DataDict::$sql_concatenateOperator during set up of data dictionary.
	public  $substr = 'substr';		/// substring operator
	public  $length = 'length';		/// string length ofperator
	public  $random = 'rand()';		/// random function
	public  $upperCase = 'upper';		/// uppercase function
	public  $fmtDate = "'Y-m-d'";	/// used by DBDate() as the default date format used by the database
	public  $fmtTimeStamp = "'Y-m-d, h:i:s A'"; /// used by DBTimeStamp as the default timestamp fmt.
	public  $true = '1';			/// string that represents TRUE for a database
	public  $false = '0';			/// string that represents FALSE for a database
	public  $replaceQuote = "\\'";	/// string to use to replace quotes
	public  $nameQuote = '';		/// string to use to quote identifiers and names. Set by ADODB_DataDict. Do not overwrite in extending classes (drivers).
	public  $charSet=false;			/// character set to use - only for interbase, postgres and oci8
	public  $metaDatabasesSQL = '';
	public  $metaTablesSQL = '';
	public  $uniqueOrderBy = false; /// All order by columns have to be unique
	public  $emptyDate = '&nbsp;';
	public  $emptyTimeStamp = '&nbsp;';
	public  $lastInsID = false;
	//--
	public  $hasInsertID = false;		/// supports autoincrement ID?
	public  $hasAffectedRows = false;	/// supports affected rows for update/delete?
	public  $hasTop = false;			/// support mssql/access SELECT TOP 10 * FROM TABLE
	public  $hasLimit = false;			/// support pgsql/mysql SELECT * FROM TABLE LIMIT 10
	public  $readOnly = false;			/// this is a readonly database - used by phpLens
	public  $hasMoveFirst = false;		/// has ability to run MoveFirst(), scrolling backwards
	public  $hasGenID = false;			/// can generate sequences using GenID();
	public  $hasTransactions = true;	/// has transactions
	//--
	public  $genID = 0;					/// sequence id used by GenID();
	/** @var falsy|callable  */
	public  $raiseErrorFn = false;		/// error function to call
	public  $isoDates = false;			/// accepts dates in ISO format
	public  $cacheSecs = 3600;			/// cache for 1 hour

	// memcache
	public  $memCache = false; /// should we use memCache instead of caching in files
	public  $memCacheHost; /// memCache host
	public  $memCachePort = 11211; /// memCache port
	public  $memCacheCompress = false; /// Use 'true' to store the item compressed (uses zlib, not supported w/memcached library)

	public  $sysDate = false; /// name of function that returns the current date. NOTE: Copied from ADODB_DataDict::$sql_sysDate during set up of data dictionary.
	public  $sysTimeStamp = false; /// name of function that returns the current timestamp. NOTE: Copied from ADODB_DataDict::$sql_sysTimeStamp during set up of data dictionary.
	public  $arrayClass = 'ADORecordSet_array'; /// name of class used to generate array recordsets, which are pre-downloaded recordsets

	public  $noNullStrings = false; /// oracle specific stuff - if true ensures that '' is converted to ' '
	public  $numCacheHits = 0;
	public  $numCacheMisses = 0;
	public  $pageExecuteCountRows = true;
	public  $uniqueSort = false; /// indicates that all fields in order by must be unique
	public  $leftOuter = false; /// operator to use for left outer join in WHERE clause
	public  $rightOuter = false; /// operator to use for right outer join in WHERE clause
	public  $ansiOuter = false; /// whether ansi outer join syntax supported
	public  $autoRollback = false; // autoRollback on PConnect().
	public  $poorAffectedRows = false; // affectedRows not working or unreliable
	/** @var false|callable  */
	public  $fnExecute = false;
	/** @var false|callable  */
	public  $fnCacheExecute = false;
	public  $blobEncodeType = false; // false=not required, 'I'=encode to integer, 'C'=encode to char
	public  $rsPrefix = "ADORecordSet_";

	public  $autoCommit = true;		/// do not modify this yourself - actually private
	public  $transOff = 0;			/// temporarily disable transactions
	public  $transCnt = 0;			/// count of nested transactions

	public  $fetchMode=false;	/// valid values are false, ADODB_FETCH_NUM, ADODB_FETCH_ASSOC and ADODB_FETCH_BOTH only.

	public  $null2null = 'null'; // in autoexecute/getinsertsql/getupdatesql, this value will be converted to a null
	public  $bulkBind = false; // enable 2D Execute array
	//
	// PRIVATE VARS
	//
	protected  $_oldRaiseFn =  false;
	protected  $_transOK = null;
	public	   $_connectionID	= false;	/// The returned link identifier whenever a successful database connection is made.
	protected  $_errorMsg = false;		/// A variable which was used to keep the returned last error message.  The value will
								/// then be returned by the ErrorMsg() function
	protected  $_errorCode = false;	/// Last error code, not guaranteed to be used - only by oci8
	protected  $_queryID = false;		/// This variable keeps the last created result link identifier

	protected  $_isPersistentConnection = false;	/// A boolean variable to state whether its a persistent connection or normal connection.	*/
	protected  $_bindInputArray = false; /// set to true if ADOConnection.Execute() permits binding of array parameters.
	protected  $_evalAll = false;
	protected  $_affected = false;
	protected  $_logsql = false;
	protected  $_transmode = ''; // transaction mode
	protected  $_dataDict = '';  //ADODB_DataDict instance. Is to be used to eventually remove all SQL statement generation, but not execution, from the drivers.


	/**
	 * Default Constructor.
	 * We define it even though it does not actually do anything. This avoids
	 * getting a PHP Fatal error:  Cannot call constructor if a subclass tries
	 * to call its parent constructor.
	 */
	public function __construct()
	{
	}

	/*
	 * Additional parameters that may be passed to drivers in the connect string
	 * Driver must be coded to accept the parameters
	 */
	protected $connectionParameters = array();

	/**
	* Adds a parameter to the connection string.
	*
	* These parameters are added to the connection string when connecting,
	* if the driver is coded to use it.
	*
	* @param	string	$parameter	The name of the parameter to set
	* @param	string	$value		The value of the parameter
	*
	* @return null
	*
	* @example, for mssqlnative driver ('CharacterSet','UTF-8')
	*/
	final public function setConnectionParameter($parameter,$value)
	{

		$this->connectionParameters[] = array($parameter=>$value);

	}

	static function Version() {
		global $ADODB_vers;

		// Semantic Version number matching regex
		$regex = '^[vV]?(\d+\.\d+\.\d+'         // Version number (X.Y.Z) with optional 'V'
			. '(?:-(?:'                         // Optional preprod version: a '-'
			. 'dev|'                            // followed by 'dev'
			. '(?:(?:alpha|beta|rc)(?:\.\d+))'  // or a preprod suffix and version number
			. '))?)(?:\s|$)';                   // Whitespace or end of string

		if (!preg_match("/$regex/", $ADODB_vers, $matches)) {
			// This should normally not happen... Return whatever is between the start
			// of the string and the first whitespace (or the end of the string).
			self::outp("Invalid version number: '$ADODB_vers'", 'Version');
			$regex = '^[vV]?(.*?)(?:\s|$)';
			preg_match("/$regex/", $ADODB_vers, $matches);
		}
		return $matches[1];
	}

	/**
		Get server version info...

		@returns An array with 2 elements: $arr['string'] is the description string,
			and $arr[version] is the version (also a string).
	*/
	public function ServerInfo() {
		return array('description' => '', 'version' => '');
	}

	public function IsConnected() {
		return !empty($this->_connectionID);
	}

	protected function _findvers($str) {
		if (preg_match('/([0-9]+\.([0-9\.])+)/',$str, $arr)) {
			return $arr[1];
		} else {
			return '';
		}
	}

	/**
	* All error messages go through this bottleneck function.
	* You can define your own handler by defining the function name in ADODB_OUTP.
	*/
	static function outp($msg,$newline=true) {
		global $ADODB_FLUSH,$ADODB_OUTP;

		if (defined('ADODB_OUTP')) {
			$fn = ADODB_OUTP;
			$fn($msg,$newline);
			return;
		} else if (isset($ADODB_OUTP)) {
			call_user_func($ADODB_OUTP,$msg,$newline);
			return;
		}

		if ($newline) {
			$msg .= "<br>\n";
		}

		if (isset($_SERVER['HTTP_USER_AGENT']) || !$newline) {
			echo $msg;
		} else {
			echo strip_tags($msg);
		}


		if (!empty($ADODB_FLUSH) && ob_get_length() !== false) {
			flush(); //  do not flush if output buffering enabled - useless - thx to Jesse Mullan
		}

	}

	public function Time() {
		$rs = $this->_Execute("select $this->sysTimeStamp");
		if ($rs && !$rs->EOF) {
			return $this->UnixTimeStamp(reset($rs->fields));
		}

		return false;
	}

	/**
	 * Parses the hostname to extract the port.
	 * Overwrites $this->host and $this->port, only if a port is specified.
	 * The Hostname can be fully or partially qualified,
	 * ie: "db.mydomain.com:5432" or "ldaps://ldap.mydomain.com:636"
	 * Any specified scheme such as ldap:// or ldaps:// is maintained.
	 */
	protected function parseHostNameAndPort() {
		$parsed_url = parse_url($this->host);
		if (is_array($parsed_url) && isset($parsed_url['host']) && isset($parsed_url['port'])) {
			if ( isset($parsed_url['scheme']) ) {
				// If scheme is specified (ie: ldap:// or ldaps://, make sure we retain that.
				$this->host = $parsed_url['scheme'] . "://" . $parsed_url['host'];
			} else {
				$this->host = $parsed_url['host'];
			}
			$this->port = $parsed_url['port'];
		}
	}

	/**
	 * Connect to database.
	 *
	 * @param string $argHostname     Host to connect to
	 * @param string $argUsername     Userid to login
	 * @param string $argPassword     Associated password
	 * @param string $argDatabaseName Database name
	 * @param bool   $forceNew        Force new connection
	 *
	 * @return bool
	 */
	public function Connect($argHostname = "", $argUsername = "", $argPassword = "", $argDatabaseName = "", $forceNew = false) {
		if ($argHostname != "") {
			$this->host = $argHostname;
		}
		// Overwrites $this->host and $this->port if a port is specified.
		$this->parseHostNameAndPort();

		if ($argUsername != "") {
			$this->user = $argUsername;
		}
		if ($argPassword != "") {
			$this->password = 'not stored'; // not stored for security reasons
		}
		if ($argDatabaseName != "") {
			$this->database = $argDatabaseName;
		}

		$this->_isPersistentConnection = false;

		if ($forceNew) {
			if ($rez=$this->_nconnect($this->host, $this->user, $argPassword, $this->database)) {
				return true;
			}
		} else {
			if ($rez=$this->_connect($this->host, $this->user, $argPassword, $this->database)) {
				return true;
			}
		}
		if (isset($rez)) {
			$err = $this->ErrorMsg();
			$errno = $this->ErrorNo();
			if (empty($err)) {
				$err = "Connection error to server '$argHostname' with user '$argUsername'";
			}
		} else {
			$err = "Missing extension for ".$this->dataProvider;
			$errno = 0;
		}
		if ($fn = $this->raiseErrorFn) {
			$fn($this->databaseType, 'CONNECT', $errno, $err, $this->host, $this->database, $this);
		}

		$this->_connectionID = false;
		if ($this->debug) {
			ADOConnection::outp( $this->host.': '.$err);
		}
		return false;
	}

	protected function _nconnect($argHostname, $argUsername, $argPassword, $argDatabaseName) {
		return $this->_connect($argHostname, $argUsername, $argPassword, $argDatabaseName);
	}

	/**
	 * Always force a new connection to database.
	 *
	 * Currently this only works with Oracle.
	 *
	 * @param string $argHostname     Host to connect to
	 * @param string $argUsername     Userid to login
	 * @param string $argPassword     Associated password
	 * @param string $argDatabaseName Database name
	 *
	 * @return bool
	 */
	public function NConnect($argHostname = "", $argUsername = "", $argPassword = "", $argDatabaseName = "") {
		return $this->Connect($argHostname, $argUsername, $argPassword, $argDatabaseName, true);
	}

	/**
	 * Establish persistent connection to database.
	 *
	 * @param string $argHostname     Host to connect to
	 * @param string $argUsername     Userid to login
	 * @param string $argPassword     Associated password
	 * @param string $argDatabaseName Database name
	 *
	 * @return bool
	 */
	public function PConnect($argHostname = "", $argUsername = "", $argPassword = "", $argDatabaseName = "") {

		if (defined('ADODB_NEVER_PERSIST')) {
			return $this->Connect($argHostname,$argUsername,$argPassword,$argDatabaseName);
		}

		if ($argHostname != "") {
			$this->host = $argHostname;
		}
		// Overwrites $this->host and $this->port if a port is specified.
		$this->parseHostNameAndPort();

		if ($argUsername != "") {
			$this->user = $argUsername;
		}
		if ($argPassword != "") {
			$this->password = 'not stored';
		}
		if ($argDatabaseName != "") {
			$this->database = $argDatabaseName;
		}

		$this->_isPersistentConnection = true;

		if ($rez = $this->_pconnect($this->host, $this->user, $argPassword, $this->database)) {
			return true;
		}
		if (isset($rez)) {
			$err = $this->ErrorMsg();
			if (empty($err)) {
				$err = "Connection error to server '$argHostname' with user '$argUsername'";
			}
			$ret = false;
		} else {
			$err = "Missing extension for ".$this->dataProvider;
			$ret = false;
		}
		if ($fn = $this->raiseErrorFn) {
			$fn($this->databaseType,'PCONNECT',$this->ErrorNo(),$err,$this->host,$this->database,$this);
		}

		$this->_connectionID = false;
		if ($this->debug) {
			ADOConnection::outp( $this->host.': '.$err);
		}
		return $ret;
	}

	public function outp_throw($msg,$src='WARN',$sql='') {
		if (defined('ADODB_ERROR_HANDLER') &&  ADODB_ERROR_HANDLER == 'adodb_throw') {
			adodb_throw($this->databaseType,$src,-9999,$msg,$sql,false,$this);
			return;
		}
		ADOConnection::outp($msg);
	}

	/**
	 * Create cache class.
	 *
	 * Code is backwards-compatible with old memcache implementation.
	 */
	protected function _CreateCache() {
		global $ADODB_CACHE, $ADODB_CACHE_CLASS;

		if ($this->memCache) {
			global $ADODB_INCLUDED_MEMCACHE;

			if (empty($ADODB_INCLUDED_MEMCACHE)) {
				include_once(ADODB_DIR.'/adodb-memcache.lib.inc.php');
			}
			$ADODB_CACHE = new ADODB_Cache_MemCache($this);
		} else {
			$ADODB_CACHE = new $ADODB_CACHE_CLASS($this);
		}
	}

	/**
	 * Format date column in sql string.
	 *
	 * See https://adodb.org/dokuwiki/doku.php?id=v5:reference:connection:sqldate
	 * for documentation on supported formats.
	 *
	 * @param string $fmt Format string
	 * @param string $col Date column; use system date if not specified.
	 */
	public function SQLDate($fmt, $col=false) {
		$vReturn = $this->_dataDict->FormatDateSQL($fmt, $col);
		return (empty($vReturn) ? "" : $vReturn[0]);
	}

	/**
	 * Prepare an sql statement and return the statement resource.
	 *
	 * For databases that do not support this, we return the $sql. To ensure
	 * compatibility with databases that do not support prepare:
	 *
	 *   $stmt = $db->Prepare("insert into table (id, name) values (?,?)");
	 *   $db->Execute($stmt,array(1,'Jill')) or die('insert failed');
	 *   $db->Execute($stmt,array(2,'Joe')) or die('insert failed');
	 *
	 * @param string $sql SQL to send to database
	 *
	 * @return mixed|false The prepared statement, or the original sql if the
	 *                     database does not support prepare.
	 */
	public function Prepare($sql) {
		return $sql;
	}

	/**
	 * Prepare a Stored Procedure and return the statement resource.
	 *
	 * Some databases, eg. mssql require a different function for preparing
	 * stored procedures. So we cannot use Prepare().
	 *
	 * For databases that do not support this, we return the $sql.
	 *
	 * @param string $sql   SQL to send to database
	 * @param mixed  $param RESERVED. DO NOT USE. THIS IS NOT USED ANY WHERE IN ADODB, BUT APPEARS TO HAVE BEEN AN ARRAY.
	 *
	 * @return mixed|false The prepared statement, or the original sql if the
	 *                     database does not support prepare.
	 */
	public function PrepareSP($sql,$param=true) {
		return $this->Prepare($sql,$param);
	}

	/**
	* PEAR DB Compat
	*/
	public function Quote($s) {
		return $this->qstr($s,false);
	}

	/**
	 * Requested by "Karsten Dambekalns" <k.dambekalns@fishfarm.de>
	 */
	public function QMagic($s) {
		return $this->qstr($s,get_magic_quotes_gpc());
	}

	public function q(&$s) {
		//if (!empty($this->qNull && $s == 'null') {
		//	return $s;
		//}
		$s = $this->qstr($s,false);
	}

	/**
	* PEAR DB Compat - do not use internally.
	*/
	public function ErrorNative() {
		return $this->ErrorNo();
	}


	/**
	 * PEAR DB Compat - do not use internally.
	 */
	public function nextId($seq_name) {
		return $this->GenID($seq_name);
	}

	/**
	 * Lock a row, will escalate and lock the table if row locking not supported
	 * will normally free the lock at the end of the transaction
	 *
	 * @param $table	name of table to lock
	 * @param $where	where clause to use, eg: "WHERE row=12". If left empty, will escalate to table lock
	 */
	public function RowLock($table,$where,$col='1 as adodbignore') {
		if($this->hasTransactions)
		{
			$tADORecordSet = null;
			$tSQL = "";

			if($this->transCnt==0) 
			{
				if(!$this->BeginTrans())
					{return false;}
			}

			$tSQL = $this->_dataDict->RowLockSQL($table,$where,$col);
			$tADORecordSet = $this->Execute($tSQL[0]);

			return !empty($tADORecordSet);
		}
		return false;
	}

	public function CommitLock($table) {
		return $this->CommitTrans();
	}

	public function RollbackLock($table) {
		return $this->RollbackTrans();
	}

	/**
	* PEAR DB Compat - do not use internally.
	*
	* The fetch modes for NUMERIC and ASSOC for PEAR DB and ADODB are identical
	* for easy porting :-)
	*
	* @param int $mode The fetchmode ADODB_FETCH_ASSOC or ADODB_FETCH_NUM
	 *
	* @return int Previous effective fetch mode
	*/
	public function SetFetchMode($mode) {
		$old = $this->fetchMode;
		$this->fetchMode = $mode;

		if ($old === false) {
			global $ADODB_FETCH_MODE;
			return $ADODB_FETCH_MODE;
		}
		return $old;
	}
	
	
	/**
	* PEAR DB Compat - do not use internally.
	*
	* The fetch modes for NUMERIC and ASSOC for PEAR DB and ADODB are identical
	* for easy porting :-)
	*
	* @param mode	The fetchmode ADODB_FETCH_ASSOC or ADODB_FETCH_NUM
	* @returns		The previous internal fetchMode  state
	*/
	public final function SetFetchMode2($mode) {
		$old = $this->fetchMode;
		$this->fetchMode = $mode;

		return $old;
	}


	/**
	* PEAR DB Compat - do not use internally.
	*
	* The fetch modes for NUMERIC and ASSOC for PEAR DB and ADODB are identical
	* for easy porting :-)
	*
	* @returns		The effective fetch mode
	*/
	public final function GetFetchMode()
	{
		global $ADODB_FETCH_MODE;

		if($this->fetchMode !== false)
			{return $this->fetchMode;}

		return $ADODB_FETCH_MODE;
	}
	

	/**
	 * PEAR DB Compat - do not use internally.
	 *
	 * @param string|array     $sql		See ADOConnection::Execute()
	 * @param array|bool $inputarr
	 *
	 * @return ADORecordSet|false
	*/
	public function Query($sql, $inputarr=false) {
		$rs = $this->Execute($sql, $inputarr);
		if (!$rs && defined('ADODB_PEAR')) {
			return ADODB_PEAR_Error();
		}
		return $rs;
	}


	/**
	 * PEAR DB Compat - do not use internally
	 */
	public function LimitQuery($sql, $offset, $count, $params=false) {
		$rs = $this->SelectLimit($sql, $count, $offset, $params);
		if (!$rs && defined('ADODB_PEAR')) {
			return ADODB_PEAR_Error();
		}
		return $rs;
	}


	/**
	 * PEAR DB Compat - do not use internally
	 */
	public function Disconnect() {
		return $this->Close();
	}

	/**
	 * Returns a placeholder for query parameters
	 * e.g. $DB->Param('a') will return
	 * - '?' for most databases
	 * - ':a' for Oracle
	 * - '$1', '$2', etc. for PostgreSQL
	 * @param string $name parameter's name, false to force a reset of the
	 *                     number to 1 (for databases that require positioned
	 *                     params such as PostgreSQL; note that ADOdb will
	 *                     automatically reset this when executing a query )
	 * @param string $type (unused)
	 * @return string query parameter placeholder
	 */
	public function Param($name,$type='C') {
		return '?';
	}

	/*
		InParameter and OutParameter are self-documenting versions of Parameter().
	*/
	public function InParameter(&$stmt,&$var,$name,$maxLen=4000,$type=false) {
		return $this->Parameter($stmt,$var,$name,false,$maxLen,$type);
	}

	/*
	*/
	public function OutParameter(&$stmt,&$var,$name,$maxLen=4000,$type=false) {
		return $this->Parameter($stmt,$var,$name,true,$maxLen,$type);

	}


	/*
	Usage in oracle
		$stmt = $db->Prepare('select * from table where id =:myid and group=:group');
		$db->Parameter($stmt,$id,'myid');
		$db->Parameter($stmt,$group,'group',64);
		$db->Execute();

		@param $stmt Statement returned by Prepare() or PrepareSP().
		@param $var PHP variable to bind to
		@param $name Name of stored procedure variable name to bind to.
		@param [$isOutput] Indicates direction of parameter 0/false=IN  1=OUT  2= IN/OUT. This is ignored in oci8.
		@param [$maxLen] Holds an maximum length of the variable.
		@param [$type] The data type of $var. Legal values depend on driver.

		WARNING: This function is supported in only 4 drivers, and it appears ill defined in at least one of
				them. ADOConnection::InParameter() and ADOConnection::OutParameter() have the same support, 
				plus apparant support on the PDO drivers.
	*/
	public function Parameter(&$stmt,&$var,$name,$isOutput=false,$maxLen=4000,$type=false) {
		return false;
	}


	public function IgnoreErrors($saveErrs=false) {
		if (!$saveErrs) {
			$saveErrs = array($this->raiseErrorFn,$this->_transOK);
			$this->raiseErrorFn = false;
			return $saveErrs;
		} else {
			$this->raiseErrorFn = $saveErrs[0];
			$this->_transOK = $saveErrs[1];
		}
	}

	/**
	 * Improved method of initiating a transaction. Used together with CompleteTrans().
	 * Advantages include:
     *
	 * a. StartTrans/CompleteTrans is nestable, unlike BeginTrans/CommitTrans/RollbackTrans.
	 *    Only the outermost block is treated as a transaction.<br>
	 * b. CompleteTrans auto-detects SQL errors, and will rollback on errors, commit otherwise.<br>
	 * c. All BeginTrans/CommitTrans/RollbackTrans inside a StartTrans/CompleteTrans block
	 *    are disabled, making it backward compatible.
	 */
	public function StartTrans($errfn = 'ADODB_TransMonitor') {
		if ($this->transOff > 0) {
			$this->transOff += 1;
			return true;
		}

		$this->_oldRaiseFn = $this->raiseErrorFn;
		$this->raiseErrorFn = $errfn;
		$this->_transOK = true;

		if ($this->debug && $this->transCnt > 0) {
			ADOConnection::outp("Bad Transaction: StartTrans called within BeginTrans");
		}
		$ok = $this->BeginTrans();
		$this->transOff = 1;
		return $ok;
	}


	/**
		Used together with StartTrans() to end a transaction. Monitors connection
		for sql errors, and will commit or rollback as appropriate.

		@autoComplete if true, monitor sql errors and commit and rollback as appropriate,
		and if set to false force rollback even if no SQL error detected.
		@returns true on commit, false on rollback.
	*/
	public function CompleteTrans($autoComplete = true) {
		if ($this->transOff > 1) {
			$this->transOff -= 1;
			return true;
		}
		$this->raiseErrorFn = $this->_oldRaiseFn;

		$this->transOff = 0;
		if ($this->_transOK && $autoComplete) {
			if (!$this->CommitTrans()) {
				$this->_transOK = false;
				if ($this->debug) {
					ADOConnection::outp("Smart Commit failed");
				}
			} else {
				if ($this->debug) {
					ADOConnection::outp("Smart Commit occurred");
				}
			}
		} else {
			$this->_transOK = false;
			$this->RollbackTrans();
			if ($this->debug) {
				ADOCOnnection::outp("Smart Rollback occurred");
			}
		}

		return $this->_transOK;
	}

	/*
		At the end of a StartTrans/CompleteTrans block, perform a rollback.
	*/
	public function FailTrans() {
		if ($this->debug)
			if ($this->transOff == 0) {
				ADOConnection::outp("FailTrans outside StartTrans/CompleteTrans");
			} else {
				ADOConnection::outp("FailTrans was called");
				adodb_backtrace();
			}
		$this->_transOK = false;
	}

	/**
		Check if transaction has failed, only for Smart Transactions.
	*/
	public function HasFailedTrans() {
		if ($this->transOff > 0) {
			return $this->_transOK == false;
		}
		return false;
	}

	/**
	 * Execute SQL
	 *
	 * @param string|array	$sql   SQL statement to execute, or possibly an array
	 *                             holding prepared statement ($sql[0] will hold sql text)
	 * @param array|false $inputarr holds the input data to bind to.
	 *                             Null elements will be set to null.
	 *
	 * @return ADORecordSet|false
	 */
	public function Execute($sql, $inputarr = false) {
		if ($this->fnExecute) {
			$fn = $this->fnExecute;
			$ret = $fn($this,$sql,$inputarr);
			if (isset($ret)) {
				return $ret;
			}
		}
		if ($inputarr !== false) {
			if (!is_array($inputarr)) {
				$inputarr = array($inputarr);
			}

			$element0 = reset($inputarr);
			# is_object check because oci8 descriptors can be passed in
			$array_2d = $this->bulkBind && is_array($element0) && !is_object(reset($element0));

			//remove extra memory copy of input -mikefedyk
			unset($element0);

			if (!is_array($sql) && !$this->_bindInputArray) {
				// @TODO this would consider a '?' within a string as a parameter...
				$sqlarr = explode('?',$sql);
				$nparams = sizeof($sqlarr)-1;

				if (!$array_2d) {
					// When not Bind Bulk - convert to array of arguments list
					$inputarr = array($inputarr);
				} else {
					// Bulk bind - Make sure all list of params have the same number of elements
					$countElements = array_map('count', $inputarr);
					if (1 != count(array_unique($countElements))) {
						$this->outp_throw(
							"[bulk execute] Input array has different number of params  [" . print_r($countElements, true) .  "].",
							'Execute'
						);
						return false;
					}
					unset($countElements);
				}
				// Make sure the number of parameters provided in the input
				// array matches what the query expects
				$element0 = reset($inputarr);
				if ($nparams != count($element0)) {
					$this->outp_throw(
						"Input array has " . count($element0) .
						" params, does not match query: '" . htmlspecialchars($sql) . "'",
						'Execute'
					);
					return false;
				}

				// clean memory
				unset($element0);

				foreach($inputarr as $arr) {
					$sql = ''; $i = 0;
					foreach ($arr as $v) {
						$sql .= $sqlarr[$i];
						// from Ron Baldwin <ron.baldwin#sourceprose.com>
						// Only quote string types
						$typ = gettype($v);
						if ($typ == 'string') {
							//New memory copy of input created here -mikefedyk
							$sql .= $this->qstr($v);
						} else if ($typ == 'double') {
							$sql .= str_replace(',','.',$v); // locales fix so 1.1 does not get converted to 1,1
						} else if ($typ == 'boolean') {
							$sql .= $v ? $this->true : $this->false;
						} else if ($typ == 'object') {
							if (method_exists($v, '__toString')) {
								$sql .= $this->qstr($v->__toString());
							} else {
								$sql .= $this->qstr((string) $v);
							}
						} else if ($v === null) {
							$sql .= 'NULL';
						} else {
							$sql .= $v;
						}
						$i += 1;

						if ($i == $nparams) {
							break;
						}
					} // while
					if (isset($sqlarr[$i])) {
						$sql .= $sqlarr[$i];
						if ($i+1 != sizeof($sqlarr)) {
							$this->outp_throw( "Input Array does not match ?: ".htmlspecialchars($sql),'Execute');
						}
					} else if ($i != sizeof($sqlarr)) {
						$this->outp_throw( "Input array does not match ?: ".htmlspecialchars($sql),'Execute');
					}

					$ret = $this->_Execute($sql);
					if (!$ret) {
						return $ret;
					}
				}
			} else {
				if ($array_2d) {
					if (is_string($sql)) {
						$stmt = $this->Prepare($sql);
					} else {
						$stmt = $sql;
					}

					foreach($inputarr as $arr) {
						$ret = $this->_Execute($stmt,$arr);
						if (!$ret) {
							return $ret;
						}
					}
				} else {
					$ret = $this->_Execute($sql,$inputarr);
				}
			}
		} else {
			$ret = $this->_Execute($sql,false);
		}

		return $ret;
	}

	protected function _Execute($sql,$inputarr=false) {
		// ExecuteCursor() may send non-string queries (such as arrays),
		// so we need to ignore those.
		if( is_string($sql) ) {
			// Strips keyword used to help generate SELECT COUNT(*) queries
			// from SQL if it exists.
			$sql = str_replace( '_ADODB_COUNT', '', $sql );
		}

		if ($this->debug) {
			global $ADODB_INCLUDED_LIB;
			if (empty($ADODB_INCLUDED_LIB)) {
				include_once(ADODB_DIR.'/adodb-lib.inc.php');
			}
			$this->_queryID = _adodb_debug_execute($this, $sql,$inputarr);
		} else {
			$this->_queryID = @$this->_query($sql,$inputarr);
		}

		// ************************
		// OK, query executed
		// ************************

		// error handling if query fails
		if ($this->_queryID === false) {
			if ($this->debug == 99) {
				adodb_backtrace(true,5);
			}
			$fn = $this->raiseErrorFn;
			if ($fn) {
				$fn($this->databaseType,'EXECUTE',$this->ErrorNo(),$this->ErrorMsg(),$sql,$inputarr,$this);
			}
			return false;
		}

		// return simplified recordset for inserts/updates/deletes with lower overhead
		if ($this->_queryID === true) {
			$rsclass = $this->rsPrefix.'empty';
			$rs = (class_exists($rsclass)) ? new $rsclass():  new ADORecordSet_empty();

			return $rs;
		}

		// return real recordset from select statement
		$rsclass = $this->rsPrefix.$this->databaseType;
		$rs = new $rsclass($this->_queryID,$this->fetchMode);
		$rs->connection = $this; // Pablo suggestion
		$rs->Init();
		if (is_array($sql)) {
			$rs->sql = $sql[0];
		} else {
			$rs->sql = $sql;
		}
		if ($rs->_numOfRows <= 0) {
			global $ADODB_COUNTRECS;
			if ($ADODB_COUNTRECS) {
				if (!$rs->EOF) {
					$rs->SwitchToBufferMode(-1,-1,!is_array($sql));
					//$rs->_queryID = $this->_queryID;
				} else
					$rs->_numOfRows = 0;
			}
		}
		return $rs;
	}

	public function CreateSequence($seqname='adodbseq',$startID=1) {
		$vSQL = $this->_dataDict->CreateSequenceSQL($seqname,$startID);

		if(empty($vSQL))
			{return false;}
		
		for($tI = 0; $tI < count($vSQL); $tI++)
		{
			$tDBReturn = $this->Execute($vSQL[$tI]);
			
			if(!$tDBReturn)
				{return false;}
		}

		return true;
	}

	public function DropSequence($seqname='adodbseq') {
		$vSQL = $this->_dataDict->DropSequenceSQL($seqname);

		if(empty($vSQL))
			{return false;}
		
		return !(!$this->Execute($vSQL[0]));
	}

	/**
	 * Generates a sequence id and stores it in $this->genID.
	 *
	 * GenID is only available if $this->hasGenID = true;
	 *
	 * @param string $seqname Name of sequence to use
	 * @param int    $startID If sequence does not exist, start at this ID
	 *
	 * @return int Sequence id, 0 if not supported
	 */
	public function GenID($seqname='adodbseq',$startID=1) {
		if (!$this->hasGenID) {
			return 0; // formerly returns false pre 1.60
		}

		$vSQL = $this->_dataDict->GenIDSQL($seqname);

		$holdtransOK = $this->_transOK;

		$save_handler = $this->raiseErrorFn;
		$this->raiseErrorFn = '';
		@($rs = $this->Execute($vSQL[0]));
		$this->raiseErrorFn = $save_handler;

		if (!$rs) {
			$this->_transOK = $holdtransOK; //if the status was ok before reset
			$this->DropSequence($seqname);
			if(!$this->CreateSequence($seqname,$startID))
			{
				$this->genID = 0;
				return 0;
			}
			$rs = $this->Execute($vSQL[0]);
		}
		
		$this->genID = 0; // false
		$this->_dataDict->event_GenID_calculateAndSetGenID($seqname, $rs);

		if ($rs) {
			$rs->Close();
		}

		return $this->genID;
	}

	/**
	 * Returns the last inserted ID.
	 *
	 * Not all databases support this feature. Some do not require to specify
	 * table or column name (e.g. MySQL).
	 *
	 * @param string $table  Table name, default ''
	 * @param string $column Column name, default ''
	 *
	 * @return int The last inserted ID.
	 */
	public function Insert_ID($table='',$column='') {
		if ($this->_logsql && $this->lastInsID) {
			return $this->lastInsID;
		}
		if ($this->hasInsertID) {
			return $this->_insertid($table,$column);
		}
		if ($this->debug) {
			ADOConnection::outp( '<p>Insert_ID error</p>');
			adodb_backtrace();
		}
		return false;
	}


	/**
	 * Portable Insert ID. Pablo Roca <pabloroca#mvps.org>
	 *
	 * @return  the last inserted ID. All databases support this. But aware possible
	 * problems in multiuser environments. Heavy test this before deploying.
	 */
	public function PO_Insert_ID($table="", $id="") {
		if ($this->hasInsertID){
			return $this->Insert_ID($table,$id);
		} else {
			return $this->GetOne("SELECT MAX($id) FROM $table");
		}
	}

	/**
	* @return # rows affected by UPDATE/DELETE
	*/
	public function Affected_Rows() {
		if ($this->hasAffectedRows) {
			if ($this->fnExecute === 'adodb_log_sql') {
				if ($this->_logsql && $this->_affected !== false) {
					return $this->_affected;
				}
			}
			$val = $this->_affectedrows();
			return ($val < 0) ? false : $val;
		}

		if ($this->debug) {
			ADOConnection::outp( '<p>Affected_Rows error</p>',false);
		}
		return false;
	}


	/**
	 * @return string the last error message
	 */
	public function ErrorMsg() {
		if ($this->_errorMsg) {
			return '!! '.strtoupper($this->dataProvider.' '.$this->databaseType).': '.$this->_errorMsg;
		} else {
			return '';
		}
	}


	/**
	 * @return int the last error number. Normally 0 means no error.
	 */
	public function ErrorNo() {
		return ($this->_errorMsg) ? -1 : 0;
	}

	public function MetaError($err=false) {
		include_once(ADODB_DIR."/adodb-error.inc.php");
		if ($err === false) {
			$err = $this->ErrorNo();
		}
		return adodb_error($this->dataProvider,$this->databaseType,$err);
	}

	public function MetaErrorMsg($errno) {
		include_once(ADODB_DIR."/adodb-error.inc.php");
		return adodb_errormsg($errno);
	}

	/**
	 * @returns an array with the primary key columns in it.
	 */
	public function MetaPrimaryKeys($pTableName, $owner=false)
	{
		return $this->_MetaPrimaryKeys(
				$this->_dataDict->ParseTableName($pTableName));
	}

	/**
	 * @param pParsedTableName  the parsed info of the table name to query. Refer to 
	 *		ADODB_DataDict::ParseIdentifierName for full specification. Note that quotation
	 *		info in is ignored, and table names are always to be quoted by implementing classes.
	 * @returns an array with the primary key columns in it.
	 */
	protected function _MetaPrimaryKeys($pParsedTableName, $owner=false) {
	// owner not used in base class - see oci8
		$p = array();
		$objs = $this->_MetaColumns($pParsedTableName);
		if ($objs) {
			foreach($objs as $v) {
				if (!empty($v->primary_key)) {
					$p[] = $v->name;
				}
			}
		}
		if (sizeof($p)) {
			return $p;
		}
		if (function_exists('ADODB_VIEW_PRIMARYKEYS')) {
			return ADODB_VIEW_PRIMARYKEYS($this->databaseType, $this->database, $pParsedTableName['raw'], $owner);
		}
		return false;
	}

	/**
	 * @returns assoc array where keys are tables, and values are foreign keys
	 *
	 * WARNING: Drivers vary widely on the implementation of the following function. Usage
	 *			is highly discouraged.
	 *
	 * Note: The above statement about the return format is the original statement that is 
	 *			from 2005 or before.
	 *			The following is a result of a code analysis survey done on implementing 
	 *			drivers (5/Apr/2021). The statistics do not include drivers that inherit their 
	 *			implementations from other drivers, which include postgres8, postgres9, 
	 *			odbtp_mssql, odbtp_access, odbtp_vfp, odbtp_oci8, odbtp_sybase,	oci8quercus, 
	 *			oci805, oci8po, and informix.
	 *		- Returns array of arrays or not?
	 *				All implementing drivers return array of arrays, except "adodb-db2.inc.php"
	 *				and "adodb-oci8.inc.php".
	 *		- Is the returned array associative?
	 *				All implementing drivers return associative arrays.
	 *		- Are the inner arrays (2nd level) associative?
	 *			- "adodb-postgres7.inc.php", "adodb-odbtp.inc.php", "adodb-mssqlnative.inc.php",
	 *					and "adodb-informix72.inc.php" return numeric inner arrays
	 *			- "adodb-sqlite3.inc.php", "adodb-pdo_sqlite.inc.php", "adodb-mysqli.inc.php",
	 *					and "adodb-mysql.inc.php" return associative inner arrays, iff the 
	 *					fetch mode is ADODB_FETCH_ASSOC. These drivers, however, also accept
	 *					an extra parameter, $associative, that will force return associative
	 *					inner arrays when set to 'true'.
	 *			- "adodb-db2.inc.php" AND "adodb-oci8.inc.php": Not applicable, because these
	 *					drivers do not return array of arrays.
	 *		- SUPPORT $upper PARAMETER?
	 *				All drivers support the parameter, except for "adodb-oci8.inc.php",
	 *				"adodb-db2.inc.php" and "adodb-db2Legacy.inc.php". All implementing drivers 
	 *				agree on the meaning of the parameter and that is to upper case keys of the
	 *				returned array (outer array) iff $upper is 'true', and leave them as they are 
	 *				if 'false'. 
	 *				However note the following exceptions:
	 *			- "adodb-sqlite3.inc.php" and "adodb-pdo_sqlite.inc.php" will lower case the keys
	 *					if $upper is 'false'. (Note that these function implementations are a 
	 *					recent addition from jan/2016)
	 *		- Format of the returned array:
	 *			- For drivers that return, or can return, an associative inner arrays:
					- "adodb-sqlite3.inc.php" and "adodb-pdo_sqlite.inc.php": 
	 *						{FOREIGN_KEY_COLUMN_NAME => {FOREIGN_KEY_COLUMN_NAME => "REFERENCE_COLUMN_NAME"}}
	 *				- "adodb-mysql.inc.php" and "adodb-mysqli.inc.php":
	 *						{REFERENCE_TABLE_NAME => {REFERENCE_COLUMN_NAME => "FOREIGN_KEY_COLUMN_NAME"}
	 *				- "adodb-db2Legacy.inc.php":
	 *						{FOREIGN_KEY_TABLE_NAME => {FOREIGN_KEY_COLUMN_NAME => "REFERENCE_COLUMN_NAME"}}
	 *			- For drivers that return, or can return, numeric inner arrays, the return is:
	 *							{REFERENCE_TABLE_NAME => { => "FOREIGN_KEY_COLUMN_NAME=REFERENCE_COLUMN_NAME"}}
	 *					HOWEVER NOTE THE FOLLOWING EXCEPTIONS:
	 *				- "adodb-sqlite3.inc.php", "adodb-pdo_sqlite.inc.php" return:
	 *								{FOREIGN_KEY_COLUMN_NAME => { => "FOREIGN_KEY_COLUMN_NAME=REFERENCE_COLUMN_NAME"}}
	 *						(Note that these function implementations are a recent addition from jan/2016)
	 *				- "adodb-informix72.inc.php": The format could not be deduced for this survey.
	 *			- For drivers that do not return array of arrays:
	 *				- "adodb-db2.inc.php":
	 *						{REFERENCE_TABLE_NAME => "FOREIGN_KEY_NAME"}
	 *				- "adodb-oci8.inc.php": The format could not be deduced for this survey.
	 *
	 *
	 * RECOMMENDATIONS: Given the above and the age of the different drivers, the following is 
	 *			recommended:
	 *		- Implementations should return an array of arrays.
	 *		- The inner arrays must be associative if the fetch mode is ADODB_FETCH_ASSOC, 
	 *				and numeric	otherwise
	 *		- The format of the array if the inner array is associative should be
	 *				{REFERENCE_TABLE_NAME => {REFERENCE_COLUMN_NAME => "FOREIGN_KEY_COLUMN_NAME"}
	 *		- The format of the array if the inner array is numeric should be
	 *				{FOREIGN_KEY_COLUMN_NAME => { => "FOREIGN_KEY_COLUMN_NAME=REFERENCE_COLUMN_NAME"}}
	 *
	 * Given the divergent implementations for this function, this function must not be used 
	 *		within ADOdb, as is already the case.
	 */
	public function MetaForeignKeys($table, $owner=false, $upper=false) {
		return false;
	}
	/**
	 * Choose a database to connect to. Many databases do not support this.
	 *
	 * @param string $dbName the name of the database to select
	 * @return bool
	 */
	public function SelectDB($dbName) {return false;}


	/**
	 * Select a limited number of rows.
	 *
	 * Will select, getting rows from $offset (1-based), for $nrows.
	 * This simulates the MySQL "select * from table limit $offset,$nrows" , and
	 * the PostgreSQL "select * from table limit $nrows offset $offset". Note that
	 * MySQL and PostgreSQL parameter ordering is the opposite of the other.
	 * eg.
	 *  SelectLimit('select * from table',3); will return rows 1 to 3 (1-based)
	 *  SelectLimit('select * from table',3,2); will return rows 3 to 5 (1-based)
	 *
	 * Uses SELECT TOP for Microsoft databases (when $this->hasTop is set)
	 * BUG: Currently SelectLimit fails with $sql with LIMIT or TOP clause already set
	 *
	 * @param string     $sql		 WARNING: SPECIFICATION NEEDS CONFIRMATION FROM CODE ANALYSIS. THIS PARAMETER LIKELY ALLOWS ARRAYS. SEE ADOConnection::Execute()
	 * @param int        $offset     Row to start calculations from (1-based)
	 * @param int        $nrows      Number of rows to get
	 * @param array|bool $inputarr   Array of bind variables
	 * @param int        $secs2cache Private parameter only used by jlim
	 *
	 * @return ADORecordSet The recordset ($rs->_isBufferMode == true)
	 */
	public function SelectLimit($sql,$nrows=-1,$offset=-1, $inputarr=false,$secs2cache=0) {
		$nrows = (int)$nrows;
		$offset = (int)$offset;

		if ($this->hasTop && $nrows > 0) {
			// suggested by Reinhard Balling. Access requires top after distinct
			// Informix requires first before distinct - F Riosa
			$ismssql = (strpos($this->databaseType,'mssql') !== false);
			if ($ismssql) {
				$isaccess = false;
			} else {
				$isaccess = (strpos($this->databaseType,'access') !== false);
			}

			if ($offset <= 0) {
				// access includes ties in result
				if ($isaccess) {
					$sql = preg_replace(
						'/(^\s*select\s+(distinctrow|distinct)?)/i',
						'\\1 '.$this->hasTop.' '.$nrows.' ',
						$sql
					);

					if ($secs2cache != 0) {
						$ret = $this->CacheExecute($secs2cache, $sql,$inputarr);
					} else {
						$ret = $this->Execute($sql,$inputarr);
					}
					return $ret; // PHP5 fix
				} else if ($ismssql){
					$sql = preg_replace(
						'/(^\s*select\s+(distinctrow|distinct)?)/i',
						'\\1 '.$this->hasTop.' '.$nrows.' ',
						$sql
					);
				} else {
					$sql = preg_replace(
						'/(^\s*select\s)/i',
						'\\1 '.$this->hasTop.' '.$nrows.' ',
						$sql
					);
				}
			} else {
				$nn = $nrows + $offset;
				if ($isaccess || $ismssql) {
					$sql = preg_replace(
						'/(^\s*select\s+(distinctrow|distinct)?)/i',
						'\\1 '.$this->hasTop.' '.$nn.' ',
						$sql
					);
				} else {
					$sql = preg_replace(
						'/(^\s*select\s)/i',
						'\\1 '.$this->hasTop.' '.$nn.' ',
						$sql
					);
				}
			}
		}

		// if $offset>0, we want to skip rows, and $ADODB_COUNTRECS is set, we buffer  rows
		// 0 to offset-1 which will be discarded anyway. So we disable $ADODB_COUNTRECS.
		global $ADODB_COUNTRECS;

		$savec = $ADODB_COUNTRECS;
		$ADODB_COUNTRECS = false;


		if ($secs2cache != 0) {
			$rs = $this->CacheExecute($secs2cache,$sql,$inputarr);
		} else {
			$rs = $this->Execute($sql,$inputarr);
		}

		$ADODB_COUNTRECS = $savec;
		if ($rs && !$rs->EOF) {
			$rs->SwitchToBufferMode($nrows,$offset);
		}
		//print_r($rs);
		return $rs;
	}

	/**
	* Create serializable recordset. Breaks rs link to connection.
	*
	* Warning: this will modify the passed $rs.
	*
	* @param ADORecordSet $rs the recordset to serialize
	*
	* @return ADORecordSet the new recordset ($rs->_isBufferMode == true)
	*/
	public function SerializableRS(&$rs) {
		$rs->SwitchToBufferMode();
		$ignore = false;
		$rs->connection = $ignore;

		return $rs;
	}

	/**
	* Important: This function is kept for backward compatibility. Do not use. Refer to
	* 		ADORecordSet::SwitchToBufferMode() for an alternative. This function now uses
	* 		ADORecordSet::SwitchToBufferMode() for its function, which means that it no
	* 		longer returns a new instance of ADORecordSet, but instead the same instance.
	*
	* Convert database recordset to an array recordset
	* input recordset's cursor should be at beginning, and
	* old $rs will be closed.
	*
	 * @param ADORecordSet $rs     the recordset to convert
	 * @param int          $nrows  number of rows to retrieve (optional)
	 * @param int          $offset offset by number of rows (optional)
	 * @param bool         $close
	 *
	 * @return ADORecordSet|false the new recordset. ($rs->_isBufferMode == true) | ($rs->_isBufferMode == false) | false
	*/
	public final function &_rs2rs(&$rs,$nrows=-1,$offset=-1,$close=true) {
		if (! $rs) {
			return false;
		}
		$dbtype = $rs->databaseType;
		if (!$dbtype) {
			$rs = $rs;  // required to prevent crashing in 4.2.1, but does not happen in 4.3.1 -- why ?
			return $rs;
		}
		if (($dbtype == 'array' || $dbtype == 'csv') && $nrows == -1 && $offset == -1) {
			$rs->MoveFirst();
			$rs = $rs; // required to prevent crashing in 4.2.1, but does not happen in 4.3.1-- why ?
			return $rs;
		}
		$rs->SwitchToBufferMode($nrows, $offset, $close);

		return $rs;
	}

	/*
	 * Return all rows.
	 *
	 * Compat with PEAR DB.
	 *
	 * @param string|array     $sql      SQL statement	See ADOConnection::Execute()
	 * @param array|bool $inputarr Input bind array		See ADOConnection::Execute()
	 *
	 * @return array|false
	*/
	public function GetAll($sql, $inputarr=false) {
		$arr = $this->GetArray($sql,$inputarr);
		return $arr;
	}

	/**
	 * Execute statement and return rows by calling 
	 *		ADORecordSet::GetAssoc($force_array, $first2cols) on the record set
	 *
	 * @param string|array     $sql         SQL statement	See ADOConnection::Execute()
	 * @param array|false $inputarr    input bind array	See ADOConnection::Execute()
	 * @param bool       $force_array	See ADORecordSet::GetAssoc()
	 * @param bool       $first2cols	See ADORecordSet::GetAssoc()
	 *
	 * @return array|false
	 */
	public function GetAssoc($sql, $inputarr = false, $force_array = false, $first2cols = false) {
		$savem = $this->fetchMode;

		// Method does not work in ADODB_FETCH_BOTH mode
		if ($this->GetFetchMode() !== ADODB_FETCH_ASSOC) {
			$this->SetFetchMode2(ADODB_FETCH_NUM);
		}

		$rs = $this->Execute($sql, $inputarr);

		$this->SetFetchMode2($savem);
		if (!$rs) {
			// Execution failure
			return false;
		}
		return $rs->GetAssoc($force_array, $first2cols);
	}

	/**
	 * Search for the results of an executed query in the cache.
	 *
	 * @param int $secs2cache
	 * @param string|false $sql         SQL statement	WARNING: NON AUTHORITATIVE. REQUIRES FURTHER CODE ANALYSIS
	 * @param array|false  $inputarr    input bind array
	 * @param bool        $force_array
	 * @param bool        $first2cols
	 *
	 * @return false|array
	 */
	public function CacheGetAssoc($secs2cache, $sql = false, $inputarr = false,$force_array = false, $first2cols = false) {
		if (!is_numeric($secs2cache)) {
			$first2cols = $force_array;
			$force_array = $inputarr;
		}
		$rs = $this->CacheExecute($secs2cache, $sql, $inputarr);
		if (!$rs) {
			return false;
		}
		return $rs->GetAssoc($force_array, $first2cols);
	}

	/**
	 * Return first element of first row of sql statement. Recordset is disposed
	 * for you.
	 *
	 * @param string		$sql		SQL statement
	 * @param array|bool	$inputarr	input bind array
	 * @return mixed
	 */
	public function GetOne($sql, $inputarr=false) {
		global $ADODB_COUNTRECS,$ADODB_GETONE_EOF;

		$crecs = $ADODB_COUNTRECS;
		$ADODB_COUNTRECS = false;

		$ret = false;
		$rs = $this->Execute($sql,$inputarr);
		if ($rs) {
			if ($rs->EOF) {
				$ret = $ADODB_GETONE_EOF;
			} else {
				$ret = reset($rs->fields);
			}

			$rs->Close();
		}
		$ADODB_COUNTRECS = $crecs;
		return $ret;
	}

	// $where should include 'WHERE fld=value'
	public function GetMedian($table, $field,$where = '') {
		$total = $this->GetOne("select count(*) from $table $where");
		if (!$total) {
			return false;
		}

		$midrow = (integer) ($total/2);
		$rs = $this->SelectLimit("select $field from $table $where order by 1",1,$midrow);
		if ($rs && !$rs->EOF) {
			return reset($rs->fields);
		}
		return false;
	}


	public function CacheGetOne($secs2cache,$sql=false,$inputarr=false) {
		global $ADODB_GETONE_EOF;

		$ret = false;
		$rs = $this->CacheExecute($secs2cache,$sql,$inputarr);
		if ($rs) {
			if ($rs->EOF) {
				$ret = $ADODB_GETONE_EOF;
			} else {
				$ret = reset($rs->fields);
			}
			$rs->Close();
		}

		return $ret;
	}

	/**
	 * Executes a statement and returns each row's first column in an array.
	 *
	 * @param string|array  $sql      SQL statement. See ADOConnection::Execute()
	 * @param array|bool $inputarr input bind array. See ADOConnection::Execute()
	 * @param bool       $trim     enables space trimming of the returned value.
	 *                             This is only relevant if the returned string
	 *                             is coming from a CHAR type field.
	 *
	 * @return array|false 1D array containning the first row of the query
	 */
	public function GetCol($sql, $inputarr = false, $trim = false) {

		$rs = $this->Execute($sql, $inputarr);
		if ($rs) {
			$rv = array();
			if ($trim) {
				while (!$rs->EOF) {
					$rv[] = trim(reset($rs->fields));
					$rs->MoveNext();
				}
			} else {
				while (!$rs->EOF) {
					$rv[] = reset($rs->fields);
					$rs->MoveNext();
				}
			}
			$rs->Close();
		} else {
			$rv = false;
		}
		return $rv;
	}

	public function CacheGetCol($secs, $sql = false, $inputarr = false,$trim=false) {
		$rs = $this->CacheExecute($secs, $sql, $inputarr);
		if ($rs) {
			$rv = array();
			if ($trim) {
				while (!$rs->EOF) {
					$rv[] = trim(reset($rs->fields));
					$rs->MoveNext();
				}
			} else {
				while (!$rs->EOF) {
					$rv[] = reset($rs->fields);
					$rs->MoveNext();
				}
			}
			$rs->Close();
		} else
			$rv = false;

		return $rv;
	}

	public function Transpose(&$rs,$addfieldnames=true) {
		$vReturn = $rs->SwitchToBufferMode();
		if (!$vReturn) {
			return false;
		}

		$rs->_transpose($addfieldnames);
		return $rs;
	}

	/*
		Calculate the offset of a date for a particular database and generate
			appropriate SQL. Useful for calculating future/past dates and storing
			in a database.

		If dayFraction=1.5 means 1.5 days from now, 1.0/24 for 1 hour.
	*/
	public function OffsetDate($dayFraction,$date=false) {
		if (!$date) {
			$date = $this->sysDate;
		}
		return  '('.$date.'+'.$dayFraction.')';
	}


	/**
	 * Executes a statement and returns a the entire recordset in an array.
	 *
	 * @param string|array     $sql      SQL statement See ADOConnection::Execute()
	 * @param array|bool $inputarr input bind array	See ADOConnection::Execute()
	 *
	 * @return array|false
	 */
	public function GetArray($sql,$inputarr=false) {
		global $ADODB_COUNTRECS;

		$savec = $ADODB_COUNTRECS;
		$ADODB_COUNTRECS = false;
		$rs = $this->Execute($sql,$inputarr);
		$ADODB_COUNTRECS = $savec;
		if (!$rs)
			if (defined('ADODB_PEAR')) {
				$cls = ADODB_PEAR_Error();
				return $cls;
			} else {
				return false;
			}
		$arr = $rs->GetArray();
		$rs->Close();
		return $arr;
	}

	public function CacheGetAll($secs2cache,$sql=false,$inputarr=false) {
		$arr = $this->CacheGetArray($secs2cache,$sql,$inputarr);
		return $arr;
	}

	public function CacheGetArray($secs2cache,$sql=false,$inputarr=false) {
		global $ADODB_COUNTRECS;

		$savec = $ADODB_COUNTRECS;
		$ADODB_COUNTRECS = false;
		$rs = $this->CacheExecute($secs2cache,$sql,$inputarr);
		$ADODB_COUNTRECS = $savec;

		if (!$rs)
			if (defined('ADODB_PEAR')) {
				$cls = ADODB_PEAR_Error();
				return $cls;
			} else {
				return false;
			}
		$arr = $rs->GetArray();
		$rs->Close();
		return $arr;
	}

	public function GetRandRow($sql, $arr= false) {
		$rezarr = $this->GetAll($sql, $arr);
		$sz = sizeof($rezarr);
		return $rezarr[abs(rand()) % $sz];
	}

	/**
	* Return one row of sql statement. Recordset is disposed for you.
	* Note that SelectLimit should not be called.
	* Note that if the fetch mode is ADODB_FETCH_ASSOC or ADODB_FETCH_BOTH, the associative
	* 		keys are case sensitive
	*
	* @param string|array     $sql      SQL statement	See ADOConnection::Execute()
	* @param array|bool $inputarr input bind array		See ADOConnection::Execute()
	 *
	* @return array|false Array containing the first row of the query
	*/
	public function GetRow($sql,$inputarr=false) {
		global $ADODB_COUNTRECS;

		$crecs = $ADODB_COUNTRECS;
		$ADODB_COUNTRECS = false;

		$rs = $this->Execute($sql,$inputarr);

		$ADODB_COUNTRECS = $crecs;
		if ($rs) {
			if (!$rs->EOF) {
				$arr = $rs->fields;
			} else {
				$arr = array();
			}
			$rs->Close();
			return $arr;
		}

		return false;
	}

	public function CacheGetRow($secs2cache,$sql=false,$inputarr=false) {
		$rs = $this->CacheExecute($secs2cache,$sql,$inputarr);
		if ($rs) {
			if (!$rs->EOF) {
				$arr = $rs->fields;
			} else {
				$arr = array();
			}

			$rs->Close();
			return $arr;
		}
		return false;
	}

	/**
	* Insert or replace a single record. Note: this is not the same as MySQL's replace.
	* ADOdb's Replace() uses update-insert semantics, not insert-delete-duplicates of MySQL.
	* Also note that no table locking is done currently, so it is possible that the
	* record be inserted twice by two programs...
	*
	* $this->Replace('products', array('prodname' =>"'Nails'","price" => 3.99), 'prodname');
	*
	* $table		table name
	* $fieldArray	associative array of data (you must quote strings yourself).
	* $keyCol		the primary key field name or if compound key, array of field names
	* autoQuote		set to true to use a heuristic to quote strings. Works with nulls and numbers
	*					but does not work with dates nor SQL functions.
	* has_autoinc	the primary key is an auto-inc field, so skip in insert.
	*
	* Currently blob replace not supported
	*
	* returns 0 = fail, 1 = update, 2 = insert
	*/

	public function Replace($table, $fieldArray, $keyCol, $autoQuote=false, $has_autoinc=false) {
		global $ADODB_INCLUDED_LIB;
		if (empty($ADODB_INCLUDED_LIB)) {
			include_once(ADODB_DIR.'/adodb-lib.inc.php');
		}

		return _adodb_replace($this, $table, $fieldArray, $keyCol, $autoQuote, $has_autoinc);
	}


	/**
	 * Will select, getting rows from $offset (1-based), for $nrows.
	 * This simulates the MySQL "select * from table limit $offset,$nrows" , and
	 * the PostgreSQL "select * from table limit $nrows offset $offset". Note that
	 * MySQL and PostgreSQL parameter ordering is the opposite of the other.
	 * eg.
	 *  CacheSelectLimit(15,'select * from table',3); will return rows 1 to 3 (1-based)
	 *  CacheSelectLimit(15,'select * from table',3,2); will return rows 3 to 5 (1-based)
	 *
	 * BUG: Currently CacheSelectLimit fails with $sql with LIMIT or TOP clause already set
	 *
	 * @param int    $secs2cache Seconds to cache data, set to 0 to force query. This is optional
	 * @param string $sql
	 * @param int    $offset     Row to start calculations from (1-based)
	 * @param int    $nrows      Number of rows to get
	 * @param array $inputarr    Array of bind variables
	 *
	 * @return ADORecordSet The recordset ($rs->_isBufferMode == true)
	 */
	public function CacheSelectLimit($secs2cache,$sql,$nrows=-1,$offset=-1,$inputarr=false) {
		if (!is_numeric($secs2cache)) {
			if ($sql === false) {
				$sql = -1;
			}
			if ($offset == -1) {
				$offset = false;
			}
												// sql,	nrows, offset,inputarr
			$rs = $this->SelectLimit($secs2cache,$sql,$nrows,$offset,$this->cacheSecs);
		} else {
			if ($sql === false) {
				$this->outp_throw("Warning: \$sql missing from CacheSelectLimit()",'CacheSelectLimit');
			}
			$rs = $this->SelectLimit($sql,$nrows,$offset,$inputarr,$secs2cache);
		}
		return $rs;
	}

	/**
	 * Flush cached recordsets that match a particular $sql statement.
	 * If $sql == false, then we purge all files in the cache.
	 */
	public function CacheFlush($sql=false,$inputarr=false) {
		global $ADODB_CACHE_DIR, $ADODB_CACHE;

		# Create cache if it does not exist
		if (empty($ADODB_CACHE)) {
			$this->_CreateCache();
		}

		if (!$sql) {
			$ADODB_CACHE->flushall($this->debug);
			return;
		}

		$f = $this->_gencachename($sql.serialize($inputarr),false);
		return $ADODB_CACHE->flushcache($f, $this->debug);
	}


	/**
	 * Private function to generate filename for caching.
	 * Filename is generated based on:
	 *
	 *  - sql statement
	 *  - database type (oci8, ibase, ifx, etc)
	 *  - database name
	 *  - userid
	 *  - setFetchMode (adodb 4.23)
	 *
	 * When not in safe mode, we create 256 sub-directories in the cache directory ($ADODB_CACHE_DIR).
	 * Assuming that we can have 50,000 files per directory with good performance,
	 * then we can scale to 12.8 million unique cached recordsets. Wow!
	 */
	protected function _gencachename($sql,$createdir) {
		global $ADODB_CACHE, $ADODB_CACHE_DIR;

		$mode = $this->GetFetchMode();

		$m = md5($sql.$this->databaseType.$this->database.$this->user.$mode);
		if (!$ADODB_CACHE->createdir) {
			return $m;
		}
		if (!$createdir) {
			$dir = $ADODB_CACHE->getdirname($m);
		} else {
			$dir = $ADODB_CACHE->createdir($m, $this->debug);
		}

		return $dir.'/adodb_'.$m.'.cache';
	}


	/**
	 * Execute SQL, caching recordsets.
	 *
	 * @param int         $secs2cache Seconds to cache data, set to 0 to force query.
	 *                                This is an optional parameter.
	 * @param string|bool $sql        SQL statement to execute. WARNING: NON AUTHORITATIVE. REQUIRES FURTHER CODE ANALYSIS
	 * @param array|bool  $inputarr   Holds the input data to bind
	 *
	 * @return ADORecordSet|false RecordSet or false
	 */
	public function CacheExecute($secs2cache,$sql=false,$inputarr=false) {
		global $ADODB_CACHE;

		if (empty($ADODB_CACHE)) {
			$this->_CreateCache();
		}

		if (!is_numeric($secs2cache)) {
			$inputarr = $sql;
			$sql = $secs2cache;
			$secs2cache = $this->cacheSecs;
		}

		if (is_array($sql)) {
			$sqlparam = $sql;
			$sql = $sql[0];
		} else
			$sqlparam = $sql;


		$md5file = $this->_gencachename($sql.serialize($inputarr),true);
		$err = '';

		if ($secs2cache > 0){
			$rs = $ADODB_CACHE->readcache($md5file,$err,$secs2cache,$this->arrayClass);
			$this->numCacheHits += 1;
		} else {
			$err='Timeout 1';
			$rs = false;
			$this->numCacheMisses += 1;
		}

		if (!$rs) {
		// no cached rs found
			if ($this->debug) {
				if (get_magic_quotes_runtime() && !$this->memCache) {
					ADOConnection::outp("Please disable magic_quotes_runtime - it corrupts cache files :(");
				}
				if ($this->debug !== -1) {
					ADOConnection::outp( " $md5file cache failure: $err (this is a notice and not an error)");
				}
			}

			$rs = $this->Execute($sqlparam,$inputarr);

			if ($rs) {
				$eof = $rs->EOF;
				$rs->SwitchToBufferMode(); // read entire recordset into memory immediately
				$rs->timeCreated = time(); // used by caching
				$txt = _rs2serialize($rs,false,$sql); // serialize

				$ok = $ADODB_CACHE->writecache($md5file,$txt,$this->debug, $secs2cache);
				if (!$ok) {
					if ($ok === false) {
						$em = 'Cache write error';
						$en = -32000;

						if ($fn = $this->raiseErrorFn) {
							$fn($this->databaseType,'CacheExecute', $en, $em, $md5file,$sql,$this);
						}
					} else {
						$em = 'Cache file locked warning';
						$en = -32001;
						// do not call error handling for just a warning
					}

					if ($this->debug) {
						ADOConnection::outp( " ".$em);
					}
				}
				if ($rs->EOF && !$eof) {
					$rs->MoveFirst();
					//$rs = csv2rs($md5file,$err);
					$rs->connection = $this; // Pablo suggestion
				}

			} else if (!$this->memCache) {
				$ADODB_CACHE->flushcache($md5file);
			}
		} else {
			$this->_errorMsg = '';
			$this->_errorCode = 0;

			if ($this->fnCacheExecute) {
				$fn = $this->fnCacheExecute;
				$fn($this, $secs2cache, $sql, $inputarr);
			}
			// ok, set cached object found
			$rs->connection = $this; // Pablo suggestion
			if ($this->debug){
				if ($this->debug == 99) {
					adodb_backtrace();
				}
				$inBrowser = isset($_SERVER['HTTP_USER_AGENT']);
				$ttl = $rs->timeCreated + $secs2cache - time();
				$s = is_array($sql) ? $sql[0] : $sql;
				if ($inBrowser) {
					$s = '<i>'.htmlspecialchars($s).'</i>';
				}

				ADOConnection::outp( " $md5file reloaded, ttl=$ttl [ $s ]");
			}
		}
		return $rs;
	}


	/*
		Similar to PEAR DB's autoExecute(), except that
		$mode can be 'INSERT' or 'UPDATE' or DB_AUTOQUERY_INSERT or DB_AUTOQUERY_UPDATE
		If $mode == 'UPDATE', then $where is compulsory as a safety measure.

		$forceUpdate means that even if the data has not changed, perform update.
	 */
	public function AutoExecute($table, $fields_values, $mode = 'INSERT', $where = false, $forceUpdate = true, $magicq = false) {
		if (empty($fields_values)) {
			$this->outp_throw('AutoExecute: Empty fields array', 'AutoExecute');
			return false;
		}
		if ($where === false && ($mode == 'UPDATE' || $mode == 2 /* DB_AUTOQUERY_UPDATE */) ) {
			$this->outp_throw('AutoExecute: Illegal mode=UPDATE with empty WHERE clause', 'AutoExecute');
			return false;
		}

		$sql = "SELECT * FROM $table";
		$rs = $this->SelectLimit($sql, 1);
		if (!$rs) {
			return false; // table does not exist
		}

		$rs->tableName = $table;
		if ($where !== false) {
			$sql .= " WHERE $where";
		}
		$rs->sql = $sql;

		switch($mode) {
			case 'UPDATE':
			case DB_AUTOQUERY_UPDATE:
				$sql = $this->GetUpdateSQL($rs, $fields_values, $forceUpdate, $magicq);
				break;
			case 'INSERT':
			case DB_AUTOQUERY_INSERT:
				$sql = $this->GetInsertSQL($rs, $fields_values, $magicq);
				break;
			default:
				$this->outp_throw("AutoExecute: Unknown mode=$mode", 'AutoExecute');
				return false;
		}
		return $sql && $this->Execute($sql);
	}


	/**
	 * Generates an Update Query based on an existing recordset.
	 * $arrFields is an associative array of fields with the value
	 * that should be assigned.
	 *
	 * Note: This function should only be used on a recordset
	 *	   that is run against a single table and sql should only
	 *		 be a simple select stmt with no groupby/orderby/limit
	 *
	 * "Jonathan Younger" <jyounger@unilab.com>
	 */
	public function GetUpdateSQL(&$rs, $arrFields,$forceUpdate=false,$magicq=false,$force=null) {
		global $ADODB_INCLUDED_LIB;

		// ********************************************************
		// This is here to maintain compatibility
		// with older adodb versions. Sets force type to force nulls if $forcenulls is set.
		if (!isset($force)) {
			global $ADODB_FORCE_TYPE;
			$force = $ADODB_FORCE_TYPE;
		}
		// ********************************************************

		if (empty($ADODB_INCLUDED_LIB)) {
			include_once(ADODB_DIR.'/adodb-lib.inc.php');
		}
		return _adodb_getupdatesql($this,$rs,$arrFields,$forceUpdate,$magicq,$force);
	}

	/**
	 * Generates an Insert Query based on an existing recordset.
	 * $arrFields is an associative array of fields with the value
	 * that should be assigned.
	 *
	 * Note: This function should only be used on a recordset
	 *       that is run against a single table.
	 */
	public function GetInsertSQL(&$rs, $arrFields,$magicq=false,$force=null) {
		global $ADODB_INCLUDED_LIB;
		if (!isset($force)) {
			global $ADODB_FORCE_TYPE;
			$force = $ADODB_FORCE_TYPE;
		}
		if (empty($ADODB_INCLUDED_LIB)) {
			include_once(ADODB_DIR.'/adodb-lib.inc.php');
		}
		return _adodb_getinsertsql($this,$rs,$arrFields,$magicq,$force);
	}


	/**
	* Update a blob column, given a where clause. There are more sophisticated
	* blob handling functions that we could have implemented, but all require
	* a very complex API. Instead we have chosen something that is extremely
	* simple to understand and use.
	*
	* Note: $blobtype supports 'BLOB' and 'CLOB', default is BLOB of course.
	*
	* Usage to update a $blobvalue which has a primary key blob_id=1 into a
	* field blobtable.blobcolumn:
	*
	*	UpdateBlob('blobtable', 'blobcolumn', $blobvalue, 'blob_id=1');
	*
	* Insert example:
	*
	*	$conn->Execute('INSERT INTO blobtable (id, blobcol) VALUES (1, null)');
	*	$conn->UpdateBlob('blobtable','blobcol',$blob,'id=1');
	*/
	public function UpdateBlob($table,$column,$val,$where,$blobtype='BLOB') {
		return $this->Execute("UPDATE $table SET $column=? WHERE $where",array($val)) != false;
	}

	/**
	* Usage:
	*	UpdateBlob('TABLE', 'COLUMN', '/path/to/file', 'ID=1');
	*
	*	$blobtype supports 'BLOB' and 'CLOB'
	*
	*	$conn->Execute('INSERT INTO blobtable (id, blobcol) VALUES (1, null)');
	*	$conn->UpdateBlob('blobtable','blobcol',$blobpath,'id=1');
	*/
	public function UpdateBlobFile($table,$column,$path,$where,$blobtype='BLOB') {
		$fd = fopen($path,'rb');
		if ($fd === false) {
			return false;
		}
		$val = fread($fd,filesize($path));
		fclose($fd);
		return $this->UpdateBlob($table,$column,$val,$where,$blobtype);
	}

	public function BlobDecode($blob) {
		return $blob;
	}

	public function BlobEncode($blob) {
		return $blob;
	}

	public function GetCharSet() {
		return $this->charSet;
	}

	public function SetCharSet($charset) {
		$this->charSet = $charset;
		return true;
	}

	public function IfNull( $field, $ifNull ) {
		return " CASE WHEN $field is null THEN $ifNull ELSE $field END ";
	}

	public function LogSQL($enable=true) {
		include_once(ADODB_DIR.'/adodb-perf.inc.php');

		if ($enable) {
			$this->fnExecute = 'adodb_log_sql';
		} else {
			$this->fnExecute = false;
		}

		$old = $this->_logsql;
		$this->_logsql = $enable;
		if ($enable && !$old) {
			$this->_affected = false;
		}
		return $old;
	}

	/**
	* Usage:
	*	UpdateClob('TABLE', 'COLUMN', $var, 'ID=1', 'CLOB');
	*
	*	$conn->Execute('INSERT INTO clobtable (id, clobcol) VALUES (1, null)');
	*	$conn->UpdateClob('clobtable','clobcol',$clob,'id=1');
	*/
	public function UpdateClob($table,$column,$val,$where) {
		return $this->UpdateBlob($table,$column,$val,$where,'CLOB');
	}

	// not the fastest implementation - quick and dirty - jlim
	// for best performance, use the actual $rs->MetaType().
	public function MetaType($t,$len=-1,$fieldobj=false) {

		if (empty($this->_metars)) {
			$rsclass = $this->rsPrefix.$this->databaseType;
			$this->_metars = new $rsclass(false,$this->fetchMode);
			$this->_metars->connection = $this;
		}
		return $this->_metars->MetaType($t,$len,$fieldobj);
	}


	/**
	*  Change the SQL connection locale to a specified locale.
	*  This is used to get the date formats written depending on the client locale.
	*
	*  Warning: Use of this function is discouraged. If a driver currently overrides 
	*		ADOConnection::$fmtTimeStamp, and most, if not all, of the drivers do, the behavior of
	*		this function is undefined.
	*/
	public function SetDateLocale($locale = 'En') {
		$this->locale = $locale;
		switch (strtoupper($locale))
		{
			case 'EN':
				$this->fmtDate="'Y-m-d'";
				$this->fmtTimeStamp = "'Y-m-d H:i:s'";
				break;

			case 'US':
				$this->fmtDate = "'m-d-Y'";
				$this->fmtTimeStamp = "'m-d-Y H:i:s'";
				break;

			case 'PT_BR':
			case 'NL':
			case 'FR':
			case 'RO':
			case 'IT':
				$this->fmtDate="'d-m-Y'";
				$this->fmtTimeStamp = "'d-m-Y H:i:s'";
				break;

			case 'GE':
				$this->fmtDate="'d.m.Y'";
				$this->fmtTimeStamp = "'d.m.Y H:i:s'";
				break;

			default:
				$this->fmtDate="'Y-m-d'";
				$this->fmtTimeStamp = "'Y-m-d H:i:s'";
				break;
		}
	}

	/**
	 * GetActiveRecordsClass Performs an 'ALL' query
	 *
	 * @param mixed $class This string represents the class of the current active record
	 * @param mixed $table Table used by the active record object
	 * @param mixed $whereOrderBy Where, order, by clauses
	 * @param mixed $bindarr
	 * @param mixed $primkeyArr
	 * @param array $extra Query extras: limit, offset...
	 * @param mixed $relations Associative array: table's foreign name, "hasMany", "belongsTo"
	 * @access public
	 * @return void
	 */
	public function GetActiveRecordsClass(
			$class, $table,$whereOrderBy=false,$bindarr=false, $primkeyArr=false,
			$extra=array(),
			$relations=array())
	{
		global $_ADODB_ACTIVE_DBS;
		## reduce overhead of adodb.inc.php -- moved to adodb-active-record.inc.php
		## if adodb-active-recordx is loaded -- should be no issue as they will probably use Find()
		if (!isset($_ADODB_ACTIVE_DBS)) {
			include_once(ADODB_DIR.'/adodb-active-record.inc.php');
		}
		return adodb_GetActiveRecordsClass($this, $class, $table, $whereOrderBy, $bindarr, $primkeyArr, $extra, $relations);
	}

	public function GetActiveRecords($table,$where=false,$bindarr=false,$primkeyArr=false) {
		$arr = $this->GetActiveRecordsClass('ADODB_Active_Record', $table, $where, $bindarr, $primkeyArr);
		return $arr;
	}

	/**
	 * Close Connection
	 */
	public function Close() {
		$rez = $this->_close();
		$this->_queryID = false;
		$this->_connectionID = false;
		return $rez;
	}

	/**
	 * Begin a Transaction. Must be followed by CommitTrans() or RollbackTrans().
	 *
	 * @return bool true if succeeded or false if database does not support transactions
	 */
	public function BeginTrans() {
		if ($this->debug) {
			ADOConnection::outp("BeginTrans: Transactions not supported for this driver");
		}
		return false;
	}

	/* set transaction mode */
	public function SetTransactionMode( $transaction_mode ) {
		$transaction_mode = $this->MetaTransaction($transaction_mode, $this->dataProvider);
		$this->_transmode  = $transaction_mode;
	}
/*
http://msdn2.microsoft.com/en-US/ms173763.aspx
http://dev.mysql.com/doc/refman/5.0/en/innodb-transaction-isolation.html
http://www.postgresql.org/docs/8.1/interactive/sql-set-transaction.html
http://www.stanford.edu/dept/itss/docs/oracle/10g/server.101/b10759/statements_10005.htm
*/
	public function MetaTransaction($mode,$db) {
		$mode = strtoupper($mode);
		$mode = str_replace('ISOLATION LEVEL ','',$mode);

		switch($mode) {

		case 'READ UNCOMMITTED':
			switch($db) {
			case 'oci8':
			case 'oracle':
				return 'ISOLATION LEVEL READ COMMITTED';
			default:
				return 'ISOLATION LEVEL READ UNCOMMITTED';
			}
			break;

		case 'READ COMMITTED':
				return 'ISOLATION LEVEL READ COMMITTED';
			break;

		case 'REPEATABLE READ':
			switch($db) {
			case 'oci8':
			case 'oracle':
				return 'ISOLATION LEVEL SERIALIZABLE';
			default:
				return 'ISOLATION LEVEL REPEATABLE READ';
			}
			break;

		case 'SERIALIZABLE':
				return 'ISOLATION LEVEL SERIALIZABLE';
			break;

		default:
			return $mode;
		}
	}

	/**
	 * If database does not support transactions, always return true as data always committed
	 *
	 * @param bool $ok  set to false to rollback transaction, true to commit
	 *
	 * @return true/false.
	 */
	public function CommitTrans($ok=true) {
		return true;
	}


	/**
	 * If database does not support transactions, rollbacks always fail, so return false
	 *
	 * @return bool
	 */
	public function RollbackTrans() {
		return false;
	}


	/**
	 * return the databases that the driver can connect to.
	 * Some databases will return an empty array.
	 *
	 * @return array|false an array of database names.
	 */
	public function MetaDatabases() {
		if ($this->metaDatabasesSQL) {
			$savem = $this->SetFetchMode2(ADODB_FETCH_NUM);

			$arr = $this->GetCol($this->metaDatabasesSQL);
			$this->SetFetchMode2($savem);

			return $arr;
		}

		return false;
	}

	/**
	 * List procedures or functions in an array. NOTE: This is currently implemented by four main drivers only. (MARCH, 2021)
	 * @param procedureNamePattern  a procedure name pattern; must match the procedure name as it is stored in the database
	 * @param catalog a catalog name; must match the catalog name as it is stored in the database;
	 * @param schemaPattern a schema name pattern;
	 *
	 * @return array of procedures on current database.
	 *
	 * Array(
	 *   [name_of_procedure] => Array(
	 *     [type] => PROCEDURE or FUNCTION
	 *     [catalog] => Catalog_name
	 *     [schema] => Schema_name
	 *     [remarks] => explanatory comment on the procedure
	 *   )
	 * )
	 */
	public function MetaProcedures($procedureNamePattern = null, $catalog  = null, $schemaPattern  = null) {
		return false;
	}


	/**
	 * @param ttype can either be 'VIEW' or 'TABLE' or false.
	 *		If false, both views and tables are returned.
	 *		"VIEW" returns only views
	 *		"TABLE" returns only tables
	 * @param showSchema returns the schema/user with the table name, eg. USER.TABLE
	 * @param mask  is the input mask - only supported by oci8 and postgresql
	 *
	 * @return  array of tables for current database.
	 */
	public function MetaTables($ttype=false,$showSchema=false,$mask=false) {
		if ($mask) {
			return false;
		}
		if ($this->metaTablesSQL) {
			$savem = $this->SetFetchMode2(ADODB_FETCH_NUM);

			$rs = $this->Execute($this->metaTablesSQL);
			$this->SetFetchMode2($savem);

			if ($rs === false) {
				return false;
			}
			$arr = $rs->GetArray();
			$arr2 = array();

			if ($hast = ($ttype && isset($arr[0][1]))) {
				$showt = strncmp($ttype,'T',1);
			}

			for ($i=0; $i < sizeof($arr); $i++) {
				if ($hast) {
					if ($showt == 0) {
						if (strncmp($arr[$i][1],'T',1) == 0) {
							$arr2[] = trim($arr[$i][0]);
						}
					} else {
						if (strncmp($arr[$i][1],'V',1) == 0) {
							$arr2[] = trim($arr[$i][0]);
						}
					}
				} else
					$arr2[] = trim($arr[$i][0]);
			}
			$rs->Close();
			return $arr2;
		}
		return false;
	}


	/**
	 * List columns in a database as an array of ADOFieldObjects.
	 * See top of file for definition of object.
	 * ACCESS: FINAL PUBLIC
	 *
	 * @param $table	table name to query optionaly formated name per the 
	 *		ADODB_DataDict::ParseIdentifierName specification
	 * @param $normalize	makes table name case-insensitive (required by some databases)
	 * @schema is optional database schema to use - not supported by all databases.
	 *
	 * @return  array of ADOFieldObjects for current table. The array is numerically indexed only
	 *			if the fetch mode is ADODB_FETCH_NUM, otherwise it is only associatively indexed
	 *			and with the keys upper cased.
	 */
	public function MetaColumns($pTableName,$pIsToNormalize=null) {
		return $this->_MetaColumns(
				$this->_dataDict->ParseTableName($pTableName, $pIsToNormalize));
	}
	
	/**
	 * List columns in a database as an array of ADOFieldObjects.
	 * See top of file for definition of object.
	 * ACCESS: PROTECTED
	 *	
	 * @param pParsedTableName  the parsed info of the table name to query. Refer to 
	 *		ADODB_DataDict::ParseIdentifierName for full specification. Note that quotation
	 *		info in is ignored, and table names are always to be quoted by implementing classes.
	 * @schema is optional database schema to use - not supported by all databases.
	 *
	 * @return  array of ADOFieldObjects for current table. The array is numerically index only
	 *			if the fetch mode is ADODB_FETCH_NUM, otherwise it is only associatively indexed
	 *			and with the keys upper cased.
	 */
	protected function _MetaColumns($pParsedTableName) {
		if (!empty($this->metaColumnsSQL)) {
			$table = $pParsedTableName['table']['name'];
			$normalize = $pParsedTableName['table']['isToNormalize'];
			$schema = @$pParsedTableName['schema']['name'];

			$savem = $this->SetFetchMode2(ADODB_FETCH_NUM);
			$rs = $this->Execute(sprintf($this->metaColumnsSQL,($normalize)?strtoupper($table):$table));
			$this->SetFetchMode2($savem);

			if ($rs === false || $rs->EOF) {
				return false;
			}

			$retarr = array();
			while (!$rs->EOF) { //print_r($rs->fields);
				$fld = new ADOFieldObject();
				$fld->name = $rs->fields[0];
				$fld->type = $rs->fields[1];
				if (isset($rs->fields[3]) && $rs->fields[3]) {
					if ($rs->fields[3]>0) {
						$fld->max_length = $rs->fields[3];
					}
					$fld->scale = $rs->fields[4];
					if ($fld->scale>0) {
						$fld->max_length += 1;
					}
				} else {
					$fld->max_length = $rs->fields[2];
				}

				if ($this->GetFetchMode() == ADODB_FETCH_NUM) {
					$retarr[] = $fld;
				} else {
					$retarr[strtoupper($fld->name)] = $fld;
				}
				$rs->MoveNext();
			}
			$rs->Close();
			return $retarr;
		}
		return false;
	}

	/**
	 * List indexes on a table as an array.
	 * ACCESS: FINAL PUBLIC
	 * @param table  table name to query optionaly formated name per the 
	 *		ADODB_DataDict::ParseIdentifierName specification
	 * @param primary ??true to only show primary keys??. 
	 *		WARNING: THE BEHAVIOR OF THIS PARAMETER DIFFERS	BETWEEN DRIVERS. 
	 *		ON SOME DRIVERS, A VALUE OF TRUE WILL GET ALL INDICES INCLUDING PRIMARY KEYS, OTHERWISE
	 *				ALL INDICES EXCLUDING PRIMARY KEYS. (ROUGHLY 2/3 OF DRIVERS)
	 *		ON SOME DRIVERS, A VALUE OF TRUE WILL GET PRIMARY KEYS ONLY, OTHERWISE ALL INDICES INCLUDING
	 *				PRIMARY KEYS. (ROUGHLY 1/3 OF DRIVERS)
	 *		NOTE THAT THIS PARAMETER IS ADDRESSED BY ABOUT 39 OF THE DRIVERS AT THE TIME OF THIS COMMENT (MARCH-2021).
	 *
	 * @return array of indexes on current table. Each element represents an index, and is itself an associative array.
	 *
	 * Array(
	 *   [name_of_index] => Array(
	 *     [unique] => true or false
	 *     [columns] => Array(
	 *       [0] => firstname
	 *       [1] => lastname
	 *     )
	 *   )
	 * )
	 */
	public function MetaIndexes($table, $primary = false, $owner = false) {
		return $this->_MetaIndexes($this->_dataDict->ParseTableName($table),
				$primary, $owner);
	}
	
	/**
	 * List indexes on a table as an array.
	 * ACCESS: PROTECTED
	 * @param pParsedTableName  the parsed info of a table name. Refer to 
	 *		ADODB_DataDict::ParseIdentifierName for full specification. Note that quotation
	 *		info in is ignored, and table names are always to be quoted by implementing classes.
	 * @param primary true to only show primary keys. Not actually used for most databases
	 *
	 * @return array of indexes on current table. Each element represents an index, and is itself an associative array.
	 *
	 * Array(
	 *   [name_of_index] => Array(
	 *     [unique] => true or false
	 *     [columns] => Array(
	 *       [0] => firstname
	 *       [1] => lastname
	 *     )
	 *   )
	 * )
	 */
	protected function _MetaIndexes($pParsedTableName, $primary = false, $owner = false) {
		return false;
	}

	/**
	 * List columns names in a table as an array.
	 * ACCESS: FINAL PUBLIC
	 * @param table	table name to query optionaly formated name per the 
	 *		ADODB_DataDict::ParseIdentifierName specification
	 *
	 * @return  array of column names for current table.
	 */
	public function MetaColumnNames($table, $numIndexes=false,$useattnum=false /* only for postgres */) {
		return $this->_MetaColumnNames($this->_dataDict->ParseTableName($table),
				$numIndexes, $useattnum);
	}

	/**
	 * List columns names in a table as an array.
	 * ACCESS: PROTECTED
	 * @param pParsedTableName  the parsed info of the table name to query. Refer to 
	 *		ADODB_DataDict::ParseIdentifierName for full specification. Note that quotation
	 *		info in is ignored, and table names are always to be quoted by implementing classes.
	 *
	 * @return  array of column names for current table.
	 */
	protected function _MetaColumnNames($pParsedTableName, $numIndexes=false,$useattnum=false /* only for postgres */) {
		$objarr = $this->_MetaColumns($pParsedTableName);
		if (!is_array($objarr)) {
			return false;
		}
		$arr = array();
		if ($numIndexes) {
			$i = 0;
			if ($useattnum) {
				foreach($objarr as $v)
					$arr[$v->attnum] = $v->name;

			} else
				foreach($objarr as $v) $arr[$i++] = $v->name;
		} else
			foreach($objarr as $v) $arr[strtoupper($v->name)] = $v->name;

		return $arr;
	}

	/**
	 * Concatenate strings.
	 *
	 * Different SQL databases used different methods to combine strings together.
	 * This function provides a wrapper.
	 *
	 * Usage: $db->Concat($str1,$str2);
	 *
	 * @param string $s Variable number of string parameters
	 *
	 * @return string concatenated string
	 */
	public function Concat() {
		$arr = func_get_args();
		return implode($this->concat_operator, $arr);
	}


	/**
	 * Converts a date "d" to a string that the database can understand.
	 *
	 * @param mixed $d a date in Unix date time format.
	 *
	 * @return string date string in database date format
	 */
	public function DBDate($d, $isfld=false) {
		if (empty($d) && $d !== 0) {
			return 'null';
		}
		if ($isfld) {
			return $d;
		}
		if (is_object($d)) {
			return $d->format($this->fmtDate);
		}

		if (is_string($d) && !is_numeric($d)) {
			if ($d === 'null') {
				return $d;
			}
			if (strncmp($d,"'",1) === 0) {
				$d = _adodb_safedateq($d);
				return $d;
			}
			if ($this->isoDates) {
				return "'$d'";
			}
			$d = ADOConnection::UnixDate($d);
		}

		return adodb_date($this->fmtDate,$d);
	}

	public function BindDate($d) {
		$d = $this->DBDate($d);
		if (strncmp($d,"'",1)) {
			return $d;
		}

		return substr($d,1,strlen($d)-2);
	}

	public function BindTimeStamp($d) {
		$d = $this->DBTimeStamp($d);
		if (strncmp($d,"'",1)) {
			return $d;
		}

		return substr($d,1,strlen($d)-2);
	}


	/**
	 * Converts a timestamp "ts" to a string that the database can understand.
	 *
	 * @param ts	a timestamp in Unix date time format.
	 *
	 * @return  timestamp string in database timestamp format
	 */
	public function DBTimeStamp($ts,$isfld=false) {
		if (empty($ts) && $ts !== 0) {
			return 'null';
		}
		if ($isfld) {
			return $ts;
		}
		if (is_object($ts)) {
			return $ts->format($this->fmtTimeStamp);
		}

		# strlen(14) allows YYYYMMDDHHMMSS format
		if (!is_string($ts) || (is_numeric($ts) && strlen($ts)<14)) {
			return adodb_date($this->fmtTimeStamp,$ts);
		}

		if ($ts === 'null') {
			return $ts;
		}
		if ($this->isoDates && strlen($ts) !== 14) {
			$ts = _adodb_safedate($ts);
			return "'$ts'";
		}
		$ts = ADOConnection::UnixTimeStamp($ts);
		return adodb_date($this->fmtTimeStamp,$ts);
	}

	/**
	 * Also in ADORecordSet.
	 * @param $v is a date string in YYYY-MM-DD format
	 *
	 * @return date in unix timestamp format, or 0 if before TIMESTAMP_FIRST_YEAR, or false if invalid date format
	 */
	static function UnixDate($v) {
		if (is_object($v)) {
		// odbtp support
		//( [year] => 2004 [month] => 9 [day] => 4 [hour] => 12 [minute] => 44 [second] => 8 [fraction] => 0 )
			return adodb_mktime($v->hour,$v->minute,$v->second,$v->month,$v->day, $v->year);
		}

		if (is_numeric($v) && strlen($v) !== 8) {
			return $v;
		}
		if (!preg_match( "|^([0-9]{4})[-/\.]?([0-9]{1,2})[-/\.]?([0-9]{1,2})|", $v, $rr)) {
			return false;
		}

		if ($rr[1] <= TIMESTAMP_FIRST_YEAR) {
			return 0;
		}

		// h-m-s-MM-DD-YY
		return @adodb_mktime(0,0,0,$rr[2],$rr[3],$rr[1]);
	}


	/**
	 * Also in ADORecordSet.
	 * @param $v is a timestamp string in YYYY-MM-DD HH-NN-SS format
	 *
	 * @return date in unix timestamp format, or 0 if before TIMESTAMP_FIRST_YEAR, or false if invalid date format
	 */
	static function UnixTimeStamp($v) {
		if (is_object($v)) {
		// odbtp support
		//( [year] => 2004 [month] => 9 [day] => 4 [hour] => 12 [minute] => 44 [second] => 8 [fraction] => 0 )
			return adodb_mktime($v->hour,$v->minute,$v->second,$v->month,$v->day, $v->year);
		}

		if (!preg_match(
			"|^([0-9]{4})[-/\.]?([0-9]{1,2})[-/\.]?([0-9]{1,2})[ ,-]*(([0-9]{1,2}):?([0-9]{1,2}):?([0-9\.]{1,4}))?|",
			($v), $rr)) return false;

		if ($rr[1] <= TIMESTAMP_FIRST_YEAR && $rr[2]<= 1) {
			return 0;
		}

		// h-m-s-MM-DD-YY
		if (!isset($rr[5])) {
			return  adodb_mktime(0,0,0,$rr[2],$rr[3],$rr[1]);
		}
		return @adodb_mktime($rr[5],$rr[6],$rr[7],$rr[2],$rr[3],$rr[1]);
	}

	/**
	 * Also in ADORecordSet.
	 *
	 * Format database date based on user defined format.
	 *
	 * @param v		is the character date in YYYY-MM-DD format, returned by database
	 * @param fmt	is the format to apply to it, using date()
	 *
	 * @return a date formatted as user desires
	 */
	public function UserDate($v,$fmt='Y-m-d',$gmt=false) {
		$tt = $this->UnixDate($v);

		// $tt == -1 if pre TIMESTAMP_FIRST_YEAR
		if (($tt === false || $tt == -1) && $v != false) {
			return $v;
		} else if ($tt == 0) {
			return $this->emptyDate;
		} else if ($tt == -1) {
			// pre-TIMESTAMP_FIRST_YEAR
		}

		return ($gmt) ? adodb_gmdate($fmt,$tt) : adodb_date($fmt,$tt);

	}

	/**
	 *
	 * @param v		is the character timestamp in YYYY-MM-DD hh:mm:ss format
	 * @param fmt	is the format to apply to it, using date()
	 *
	 * @return a timestamp formatted as user desires
	 */
	public function UserTimeStamp($v,$fmt='Y-m-d H:i:s',$gmt=false) {
		if (!isset($v)) {
			return $this->emptyTimeStamp;
		}
		# strlen(14) allows YYYYMMDDHHMMSS format
		if (is_numeric($v) && strlen($v)<14) {
			return ($gmt) ? adodb_gmdate($fmt,$v) : adodb_date($fmt,$v);
		}
		$tt = $this->UnixTimeStamp($v);
		// $tt == -1 if pre TIMESTAMP_FIRST_YEAR
		if (($tt === false || $tt == -1) && $v != false) {
			return $v;
		}
		if ($tt == 0) {
			return $this->emptyTimeStamp;
		}
		return ($gmt) ? adodb_gmdate($fmt,$tt) : adodb_date($fmt,$tt);
	}

	public function escape($s,$magic_quotes=false) {
		return $this->addq($s,$magic_quotes);
	}

	/**
	* Quotes a string, without prefixing nor appending quotes.
	*/
	public function addq($s,$magic_quotes=false) {
		if (!$magic_quotes) {
			if ($this->replaceQuote[0] == '\\') {
				// only since php 4.0.5
				$s = str_replace(array('\\',"\0"),array('\\\\',"\\\0"),$s);
				//$s = str_replace("\0","\\\0", str_replace('\\','\\\\',$s));
			}
			return  str_replace("'",$this->replaceQuote,$s);
		}

		// undo magic quotes for "
		$s = str_replace('\\"','"',$s);

		if ($this->replaceQuote == "\\'" || ini_get('magic_quotes_sybase')) {
			// ' already quoted, no need to change anything
			return $s;
		} else {
			// change \' to '' for sybase/mssql
			$s = str_replace('\\\\','\\',$s);
			return str_replace("\\'",$this->replaceQuote,$s);
		}
	}

	/**
	 * Correctly quotes a string so that all strings are escaped. We prefix and append
	 * to the string single-quotes.
	 * An example is  $db->qstr("Don't bother",magic_quotes_runtime());
	 *
	 * @param string $s            The string to quote
	 * @param bool   $magic_quotes If $s is GET/POST var, set to get_magic_quotes_gpc().
	 *                             This undoes the stupidity of magic quotes for GPC.
	 *
	 * @return string Quoted string to be sent back to database
	 */
	public function qstr($s,$magic_quotes=false) {
		if (!$magic_quotes) {
			if ($this->replaceQuote[0] == '\\'){
				// only since php 4.0.5
				$s = str_replace(array('\\',"\0"),array('\\\\',"\\\0"),$s);
				//$s = str_replace("\0","\\\0", str_replace('\\','\\\\',$s));
			}
			return  "'".str_replace("'",$this->replaceQuote,$s)."'";
		}

		// undo magic quotes for "
		$s = str_replace('\\"','"',$s);

		if ($this->replaceQuote == "\\'" || ini_get('magic_quotes_sybase')) {
			// ' already quoted, no need to change anything
			return "'$s'";
		} else {
			// change \' to '' for sybase/mssql
			$s = str_replace('\\\\','\\',$s);
			return "'".str_replace("\\'",$this->replaceQuote,$s)."'";
		}
	}


	/**
	* Will select the supplied $page number from a recordset, given that it is paginated in pages of
	* $nrows rows per page. It also saves two boolean values saying if the given page is the first
	* and/or last one of the recordset. Added by Ivn Oliva to provide recordset pagination.
	*
	* See docs-adodb.htm#ex8 for an example of usage.
	*
	* @param sql
	* @param nrows		is the number of rows per page to get
	* @param page		is the page number to get (1-based)
	* @param [inputarr]	array of bind variables
	* @param [secs2cache]		is a private parameter only used by jlim
	* @return		the recordset ($rs->databaseType == 'array')
	*
	* NOTE: phpLens uses a different algorithm and does not use PageExecute().
	*
	*/
	public function PageExecute($sql, $nrows, $page, $inputarr=false, $secs2cache=0) {
		global $ADODB_INCLUDED_LIB;
		if (empty($ADODB_INCLUDED_LIB)) {
			include_once(ADODB_DIR.'/adodb-lib.inc.php');
		}
		if ($this->pageExecuteCountRows) {
			$rs = _adodb_pageexecute_all_rows($this, $sql, $nrows, $page, $inputarr, $secs2cache);
		} else {
			$rs = _adodb_pageexecute_no_last_page($this, $sql, $nrows, $page, $inputarr, $secs2cache);
		}
		return $rs;
	}


	/**
	* Will select the supplied $page number from a recordset, given that it is paginated in pages of
	* $nrows rows per page. It also saves two boolean values saying if the given page is the first
	* and/or last one of the recordset. Added by Ivn Oliva to provide recordset pagination.
	*
	* @param secs2cache	seconds to cache data, set to 0 to force query
	* @param sql
	* @param nrows		is the number of rows per page to get
	* @param page		is the page number to get (1-based)
	* @param [inputarr]	array of bind variables
	* @return		the recordset ($rs->databaseType == 'array')
	*/
	public function CachePageExecute($secs2cache, $sql, $nrows, $page,$inputarr=false) {
		/*switch($this->dataProvider) {
		case 'postgres':
		case 'mysql':
			break;
		default: $secs2cache = 0; break;
		}*/
		$rs = $this->PageExecute($sql,$nrows,$page,$inputarr,$secs2cache);
		return $rs;
	}

	/**
	* Returns the maximum size of a MetaType C field. If the method
	* is not defined in the driver returns ADODB_STRINGMAX_NOTSET
	*
	* @return int
	*/
	function charMax()
	{
		return ADODB_STRINGMAX_NOTSET;
	}

	/**
	* Returns the maximum size of a MetaType X field. If the method
	* is not defined in the driver returns ADODB_STRINGMAX_NOTSET
	*
	* @return int
	*/
	function textMax()
	{
		return ADODB_STRINGMAX_NOTSET;
	}

	/**
	* Returns a substring of a varchar type field
	*
	* Some databases have variations of the parameters, which is why
	* we have an ADOdb function for it
	*
	* @param	string	$fld	The field to sub-string
	* @param	int		$start	The start point
	* @param	int		$length	An optional length
	*
	* @return	The SQL text
	*/
	function substr($fld,$start,$length=0) {
		$text = "{$this->substr}($fld,$start";
		if ($length > 0)
			$text .= ",$length";
		$text .= ')';
		return $text;
	}

	/*
	 * Formats the date into Month only format MM with leading zeroes
	 *
	 * @param	string		$fld	The name of the date to format
	 *
	 * @return	string				The SQL text
	 */
	function month($fld) {
		$x = $this->SQLDate('m',$fld);

		return $x;
	}

	/*
	 * Formats the date into Day only format DD with leading zeroes
	 *
	 * @param	string		$fld	The name of the date to format
	 * @return	string		The SQL text
	 */
	function day($fld) {
		$x = $this->SQLDate('d',$fld);
		return $x;
	}

	/*
	 * Formats the date into year only format YYYY
	 *
	 * @param	string		$fld The name of the date to format
	 *
	 * @return	string		The SQL text
	 */
	function year($fld) {
		$x = $this->SQLDate('Y',$fld);
		return $x;
	}

	/**
	 * Get the last error recorded by PHP and clear the message.
	 *
	 * By clearing the message, it becomes possible to detect whether a new error
	 * has occurred, even when it is the same error as before being repeated.
	 *
	 * @return array|null Array if an error has previously occurred. Null otherwise.
	 */
	protected function resetLastError() {
		$error = error_get_last();

		if (is_array($error)) {
			$error['message'] = '';
		}

		return $error;
	}

	/**
	 * Compare a previously stored error message with the last error recorded by PHP
	 * to determine whether a new error has occurred.
	 *
	 * @param array|null $old Optional. Previously stored return value of error_get_last().
	 *
	 * @return string The error message if a new error has occurred
	 *                or an empty string if no (new) errors have occurred..
	 */
	protected function getChangedErrorMsg($old = null) {
		$new = error_get_last();

		if (is_null($new)) {
			// No error has occurred yet at all.
			return '';
		}

		if (is_null($old)) {
			// First error recorded.
			return $new['message'];
		}

		$changed = false;
		foreach($new as $key => $value) {
			if ($new[$key] !== $old[$key]) {
				$changed = true;
				break;
			}
		}

		if ($changed === true) {
			return $new['message'];
		}

		return '';
	}

	/**
	*	ACCESS: PUBLIC
	*	Refer to ADODB_DataDict::ParseIdentifierName for full specification.
	*/
	public function ParseIdentifierName($pIdentifierName,  $pPassedIsToNormalizeParameter = -1)
	{
		return $this->_dataDict->ParseIdentifierName($pIdentifierName,  
				$pPassedIsToNormalizeParameter);		
	}

	/**
	*	ACCESS: PUBLIC
	*	Refer to ADODB_DataDict::ParseTableName for full specification.
	*/
	public function ParseTableName($pTableName, $pPassedIsToNormalizeParameter = -1)
	{
		return $this->_dataDict->ParseTableName($pTableName,  
				$pPassedIsToNormalizeParameter);
	}
	
	public function setDataDictFromADONewConnection($pADODB_DataDict)
	{
		$tBackTrace = debug_backtrace();

		if($tBackTrace[1]['function'] === "ADONewConnection")
			{$this->_dataDict = $pADODB_DataDict;}
	}

	public function ForceNameQuote($pName = NULL)
		{return $this->_dataDict->ForceNameQuote($pName);}

	public final function NormaliseIdentifierNameIf($pCondition, $pIdentifierName)
	{
		return ($pCondition ? $this->_dataDict->NormaliseIdentifierName($pIdentifierName) : 
				$pIdentifierName);
	}

	public function BuildTableName($pTableName, $pSchemaName = NULL)
		{return ($pSchemaName ? ($pSchemaName.".".$pTableName) : $pTableName);}
} // end class ADOConnection



	//==============================================================================================
	// CLASS ADOFetchObj
	//==============================================================================================

	/**
	* Internal placeholder for record objects. Used by ADORecordSet->FetchObj().
	*/
	class ADOFetchObj {
	};

	//==============================================================================================
	// CLASS ADORecordSet_empty
	//==============================================================================================

	class ADODB_Iterator_empty implements Iterator {

		private $rs;

		public function __construct($rs) {
			$this->rs = $rs;
		}

		public function rewind() {}

		public function valid() {
			return !$this->rs->EOF;
		}

		public function key() {
			return false;
		}

		public function current() {
			return false;
		}

		public function next() {}

		public function __call($func, $params) {
			return call_user_func_array(array($this->rs, $func), $params);
		}

		public function hasMore() {
			return false;
		}

	}


	/**
	* Lightweight recordset when there are no records to be returned
	*/
	class ADORecordSet_empty implements IteratorAggregate
	{
		public  $dataProvider = 'empty';
		public  $databaseType = false;
		public  $EOF = true;
		public  $_numOfRows = 0;
		/** @var bool|false  */
		public  $fields = false;
		public  $connection = false;

		public function RowCount() {
			return 0;
		}

		public function RecordCount() {
			return 0;
		}

		public function PO_RecordCount() {
			return 0;
		}

		public function Close() {
			return true;
		}

		public function FetchRow() {
			return false;
		}

		public function FieldCount() {
			return 0;
		}

		public function Init() {}

		public function getIterator() {
			return new ADODB_Iterator_empty($this);
		}

		public function GetAssoc() {
			return array();
		}

		public function GetArray() {
			return array();
		}

		public function GetAll() {
			return array();
		}

		public function GetArrayLimit() {
			return array();
		}

		public function GetRows() {
			return array();
		}

		public function GetRowAssoc() {
			return array();
		}

		public function MaxRecordCount() {
			return 0;
		}

		public function NumRows() {
			return 0;
		}

		public function NumCols() {
			return 0;
		}
	}

	//==============================================================================================
	// DATE AND TIME FUNCTIONS
	//==============================================================================================
	if (!defined('ADODB_DATE_VERSION')) {
		include_once(ADODB_DIR.'/adodb-time.inc.php');
	}

	//==============================================================================================
	// CLASS ADORecordSet
	//==============================================================================================

	class ADODB_Iterator implements Iterator {

		private $rs;

		public function __construct($rs) {
			$this->rs = $rs;
		}

		public function rewind() {
			$this->rs->MoveFirst();
		}

		public function valid() {
			return !$this->rs->EOF;
		}

		public function key() {
			return $this->rs->_currentRow;
		}

		public function current() {
			return $this->rs->fields;
		}

		public function next() {
			$this->rs->MoveNext();
		}

		public function __call($func, $params) {
			return call_user_func_array(array($this->rs, $func), $params);
		}

		public function hasMore() {
			return !$this->rs->EOF;
		}

	}


	/**
	 * RecordSet class that represents the dataset returned by the database.
	 * To keep memory overhead low, this class holds only the current row in memory.
	 * No prefetching of data is done, so the RecordCount() can return -1 ( which
	 * means recordcount not known).
	 */
	class ADORecordSet implements IteratorAggregate {

	/**
	 * public variables
	 */
	public  $dataProvider = "native";
	/** @var bool|array  */
	public  $fields = false;	/// holds the current row data. Note: When accessing fields using associative keys, use Fields() instead.
	public  $blobSize = 100;	/// any varchar/char field this size or greater is treated as a blob
							/// in other words, we use a text area for editing.
	public  $canSeek = false;	/// indicates that seek is supported
	public  $sql;				/// sql text
	public  $EOF = false;		/// Indicates that the current record position is after the last record in a Recordset object.

	public  $emptyTimeStamp = '&nbsp;'; /// what to display when $time==0
	public  $emptyDate = '&nbsp;'; /// what to display when $time==0
	public  $debug = false;
	public  $timeCreated=0;		/// datetime in Unix format rs created -- for cached recordsets

	public  $bind = false;		/// associates normalized associative keys to the entries of $fields which may or may not be keyed associatively. Note: Must be set to false whenever $fields is changed.
	protected $fromBindKeysToColumnNames; /// associates the keys of bind, which are normalized, to the original column names. Invalid if $bind is false.
	public  $fetchMode;			/// default fetch mode. Valid values are ADODB_FETCH_NUM, ADODB_FETCH_ASSOC and ADODB_FETCH_BOTH only;do not confuse with ADOConnection::fetchMode.
	public  $connection = false; /// the parent connection

	/**
	 *	private variables
	 */
	public  $_numOfRows = -1;	/** number of rows, or -1 */
	protected  $_numOfFields = -1;	/** number of fields in recordset */
	public  $_queryID = -1;		/** This variable keeps the result link identifier.	-1: indicates unset.  false: indicates set but closed or not a resource(used in buffer mode)*/
	protected  $_currentRow = -1;	/** This variable keeps the current row in the Recordset.	*/
	protected  $_inited = false;	/** Init() should only be called once */
	protected  $_obj;				/** Used by FetchObj */
	protected  $_names;			/** Used by FetchObj */

	protected  $_currentPage = -1;	/** Added by Ivn Oliva to implement recordset pagination */
	protected  $_atFirstPage = false;	/** Added by Ivn Oliva to implement recordset pagination */
	protected  $_atLastPage = false;	/** Added by Ivn Oliva to implement recordset pagination */
	protected  $_lastPageNo = -1;
	protected  $_maxRecordCount = 0;
	public  $datetime = false;
	

	//BUFFERED MODE
	private    $_isBufferMode = false; /** Sub classes should never need to know whether it is buffer mode, and should always be able to assume that it is not*/
	protected  $_array;	// holds the 2-dimensional data array
	protected  $_fieldobjects; // holds array of field objects
	protected  $affectedrows = false;
	protected  $insertid = false;
	protected  $compat = false;

	/**
	 * Constructor
	 *
	 * @param queryID	this is the queryID returned by ADOConnection->_query()
	 *
	 */
	public function __construct($queryID, $mode=false) {
		global $ADODB_FETCH_MODE;

		$this->_queryID = $queryID;
		$this->fetchMode = (($mode === false) ? $ADODB_FETCH_MODE : $mode);
	}

	/*
		Call to Close() is generally not necessary because drivers will free the pertaining resources
		automatically. This has been confirmed for most drivers. See:
		
		https://www.php.net/manual/en/function.fbsql-free-result.php {fbsql_free_result}
		https://www.ic.unicamp.br/~celio/mc527/interbase/PHPapi3506b.html {fbird_free_result, ibase_free_result, COULD BE INVALID}
		https://www.php.net/manual/en/function.ldap-free-result.php {ldap_free_result}
		https://php-legacy-docs.zend.com/manual/php5/en/function.mssql-free-result {mssql_free_result}
		https://www.sitepoint.com/sql-server-php/ {sqlsrv_free_stmt}
		https://www.php.net/manual/en/function.mysql-free-result.php {mysql_free_result}
		https://stackoverflow.com/questions/14088155/mysqli-free-result-necessary {mysqli_free_result}
		https://www.php.net/manual/en/function.odbc-free-result.php {odbc_free_result}
		Adodb Src Code file: drivers/adodb-oracle.inc.php {ora_close, source from 14 years ago also had comment}
		https://www.php.net/manual/en/function.pg-free-result.php {pg_free_result}
		https://php-legacy-docs.zend.com/manual/php5/en/function.sybase-free-result {sybase_free_result}
		https://devzone.advantagedatabase.com/dz/webhelp/Advantage11/php_ads_free_result.htm{ads_free_result}
		https://www.php.net/manual/en/function.db2-free-result.php {db2_free_result}
		https://stackoverflow.com/questions/8380185/is-it-necessary-to-close-an-adodb-recordset-object-before-setting-it-to-nothing {ADODB::Recordset::Close, For driver drivers/adodb-ado5.inc.php}
		
		However, was not able to confirm for the following:
		ifx_free_result				{ADORecordset_informix72, drivers/adodb-informix72.inc.php}
		oci_free_statement			{ADORecordset_oci8, drivers/adodb-oci8.inc.php}
		odbtp_free_query			{ADORecordSet_odbtp, drivers/adodb-odbtp.inc.php}
		
		Note that the code was originally committed in "Sep 13, 2015", and not part of the original apparent 
		specification that suggests any responsibility of necessary cleanup is to be on the client code.
	
	public function __destruct() {
		$this->Close();
	}
	*/

	public function getIterator() {
		return new ADODB_Iterator($this);
	}

	/* this is experimental - i don't really know what to return... */
	public function __toString() {
		include_once(ADODB_DIR.'/toexport.inc.php');
		return _adodb_export($this,',',',',false,true);
	}


	public final function Init() {
		if ($this->_inited) {
			return;
		}
		$this->_inited = true;
		if($this->_isBufferMode)
			{$this->_initrsForBufferMode();}
		elseif ($this->_queryID) {			
			@$this->_initrs();
		} else {
			$this->_numOfRows = 0;
			$this->_numOfFields = 0;
		}
		if ($this->_numOfRows != 0 && $this->_numOfFields && $this->_currentRow == -1) {
			$this->_currentRow = 0;
			if ($this->EOF = ($this->_callFetch() === false)) {
				$this->_numOfRows = 0; // _numOfRows could be -1
			}
		} else {
			$this->EOF = true;
		}
		
		if ($this->EOF) { //EXPERIMENTAL: Based on the OCI's driver's treatment
			$this->bind = false;
			$this->fields = false;
			$this->_numOfRows = 0;
		}
	}

	/*Should be implemented by child classes when needed.*/	
	protected function _initrs() {}

	/*
		Should be implemented by child classes when needed. Child classes should not call this 
		function, but instead call $this->_callFetch();
	*/	
	protected function _fetch() {}

	/*
		Added to add support for fetching in buffer mode. Child classes should call this function
			instead of $this->_fetch().
	*/
	protected final function _callFetch()
	{
		if($this->_isBufferMode)
		{
			$pos = $this->_currentRow;

			if ($this->_numOfRows <= $pos) {
				if (!$this->compat) {
					$this->fields = false;
				}
				return false;
			}
			$this->fields = $this->_array[$pos];
			return true;
		}
		else
			{return $this->_fetch();}
	}

	protected function _initrsForBufferMode()
	{
		$this->_numOfRows =  sizeof($this->_array);

		$this->_numOfFields = sizeof($this->_fieldobjects);
	}

	/*
		Should be implemented by child classes when needed. Child classes should not call this 
		function, but instead call $this->_callSeek();
	*/	
	protected function _seek($row) {}

	/*
		Added to add support for seeking in buffer mode. Child classes should call this function
			instead of $this->_seek().
	*/
	protected final function _callSeek($row)
	{
		if($this->_isBufferMode)
		{
			if (sizeof($this->_array) && 0 <= $row && $row < $this->_numOfRows) {
				$this->_currentRow = $row;
				$this->fields = $this->_array[$row];
				return true;
			}
			return false;
		}
		else
			{return $this->_seek($row);}
	}

	/**
	 * Generate a SELECT tag from a recordset, and return the HTML markup.
	 *
	 * If the recordset has 2 columns, we treat the first one as the text to
	 * display to the user, and the second as the return value. Default
	 * strings are compared with the FIRST column.
	 *
	 * Warning: Fetch mode must be ADODB_FETCH_NUM (see ::_adodb_getmenu()).
	 *
	 * Changes by glen.davies@cce.ac.nz to support multiple hilited items
	 *
	 * @param string       $name            Name of SELECT tag
	 * @param string|array $defstr          The value to highlight. Use an array for multiple highlight values.
	 * @param bool|string $blank1stItem     True to create an empty item (default), False not to add one; (Original authoritative comment: true to leave the 1st item in list empty)
	 *                                      'string' to set its label and 'value:string' to assign a value to it.
	 * @param bool         $multiple        True for multi-select list (Original authoritative comment: true for listbox, false for popup)
	 * @param int          $size            Number of rows to show (applies to multi-select list only)
	 * @param string       $selectAttr      Additional attributes to defined for SELECT tag,
	 *                                      useful for holding javascript onChange='...' handlers, CSS class, etc.
	 * @param bool         $compareFields0	when we have 2 cols in recordset, we compare the defstr with
	 *										column 0 (1st col) if this is true. This is not documented.
	 *
	 * @return string HTML
	 */
	public function GetMenu($name,$defstr='',$blank1stItem=true,$multiple=false,
			$size=0, $selectAttr='',$compareFields0=true)
	{
		global $ADODB_INCLUDED_LIB;
		
		if($this->CheckIfCurrentRowIsNumeric() != 1)
		{
			ADOConnection::outp("ADORecordSet::GetMenu(): Warning: Fetch mode is either set to ".
					"ADODB_FETCH_ASSOC, or is set to ADODB_FETCH_BOTH and associative and ".
					"numeric keys overlaped.");

			return "";
		}

		if (empty($ADODB_INCLUDED_LIB)) {
			include_once(ADODB_DIR.'/adodb-lib.inc.php');
		}
		return _adodb_getmenu($this, $name,$defstr,$blank1stItem,$multiple,
			$size, $selectAttr,$compareFields0);
	}



	/**
	 * Generate a SELECT tag string from a recordset, and return the string.
	 * If the recordset has 2 cols, we treat the 1st col as the containing
	 * the text to display to the user, and 2nd col as the return value. Default
	 * strings are compared with the SECOND column.
	 *
	 * Warning: Fetch mode must be ADODB_FETCH_NUM (see ::_adodb_getmenu()).
	 */
	public function GetMenu2($name,$defstr='',$blank1stItem=true,$multiple=false,$size=0, $selectAttr='') {
		
		if($this->CheckIfCurrentRowIsNumeric() != 1)
		{
			ADOConnection::outp("ADORecordSet::GetMenu2(): Warning: Fetch mode is either set to ".
					"ADODB_FETCH_ASSOC, or is set to ADODB_FETCH_BOTH and associative and ".
					"numeric keys overlaped.");

			return "";
		}

		return $this->GetMenu($name,$defstr,$blank1stItem,$multiple,
			$size, $selectAttr,false);
	}

	/*
		Grouped Menu
		
		Warning: Fetch mode must be ADODB_FETCH_NUM (see ::_adodb_getmenu_gp()).
	*/
	public function GetMenu3($name,$defstr='',$blank1stItem=true,$multiple=false,
			$size=0, $selectAttr='')
	{
		global $ADODB_INCLUDED_LIB;
		
		if($this->CheckIfCurrentRowIsNumeric() != 1)
		{
			ADOConnection::outp("ADORecordSet::GetMenu3(): Warning: Fetch mode is either set to ".
					"ADODB_FETCH_ASSOC, or is set to ADODB_FETCH_BOTH and associative and ".
					"numeric keys overlaped.");

			return "";
		}

		if (empty($ADODB_INCLUDED_LIB)) {
			include_once(ADODB_DIR.'/adodb-lib.inc.php');
		}
		return _adodb_getmenu_gp($this, $name,$defstr,$blank1stItem,$multiple,
			$size, $selectAttr,false);
	}

	/**
	 * return recordset as a 2-dimensional array.
	 *
	 * @param int $nRows  Number of rows to return. -1 means every row.
	 *
	 * @return array indexed by the rows (0-based) from the recordset
	 */
	public final function GetArray($nRows = -1) {
		global $ADODB_EXTENSION;

		if($this->_isBufferMode)
		{
			if ($nRows == -1 && $this->_currentRow <= 0 /*&& !$this->_skiprow1*/) {
				return $this->_array;
			}/* else {
				$arr = ADORecordSet::GetArray($nRows);
				return $arr;
			}*/
		}

		if ($ADODB_EXTENSION) {
			$results = adodb_getall($this,$nRows);
			return $results;
		}

		$results = array();
		$cnt = 0;
		while (!$this->EOF && $nRows != $cnt) {
			$results[] = $this->fields;
			$this->MoveNext();
			$cnt++;
		}
		return $results;
	}

	public function GetAll($nRows = -1) {
		$arr = $this->GetArray($nRows);
		return $arr;
	}

	/*
	* Some databases allow multiple recordsets to be returned. This function
	* will return true if there is a next recordset, or false if no more.
	*/
	public function NextRecordSet() {
		$vReturn = false;

		if($this->_queryID)
			{$vReturn = $this->_NextRecordSet();}

		if($vReturn === true)
		{
			$this->_isBufferMode = false;
			$this->ReInit();
		}

		return $vReturn;
	}

	protected function _NextRecordSet() {
		return false;
	}

	/**
	 * return recordset as a 2-dimensional array.
	 * Helper function for ADOConnection->SelectLimit()
	 *
	 * @param offset	is the row to start calculations from (1-based)
	 * @param [nrows]	is the number of rows to return
	 *
	 * @return an array indexed by the rows (0-based) from the recordset
	 */
	protected function _GetArrayLimit($nrows,$offset=-1) {
		if ($offset <= 0) {
			$arr = $this->GetArray($nrows);
			return $arr;
		}

		$this->Move($offset);

		$results = array();
		$cnt = 0;
		while (!$this->EOF && $nrows != $cnt) {
			$results[$cnt++] = $this->fields;
			$this->MoveNext();
		}

		return $results;
	}
	
	public final function GetArrayLimit($nrows,$offset=-1)
	{
		if($this->_isBufferMode)
			{return ADORecordSet::_GetArrayLimit($nrows,$offset);}
		else
			{return $this->_GetArrayLimit($nrows,$offset);}
	}		


	/**
	 * Synonym for GetArray() for compatibility with ADO.
	 *
	 * @param [nRows]  is the number of rows to return. -1 means every row.
	 *
	 * @return an array indexed by the rows (0-based) from the recordset
	 */
	public function GetRows($nRows = -1) {
		$arr = $this->GetArray($nRows);
		return $arr;
	}

	/**
	 * return whole recordset as a 2-dimensional associative array if
	 * there are more than 2 columns. The first column is treated as the
	 * key and is not included in the array. If there is only 2 columns,
	 * it will return a 1 dimensional array of key-value pairs unless
	 * $force_array == true. This recordset method is currently part of
	 * the API, but may not be in later versions of ADOdb. By preference, use
	 * ADOconnnection::getAssoc()
	 *
	 * @param bool	$force_array	(optional) Has only meaning if we have 2 data
	 *								columns. If false, a 1 dimensional
	 * 								array is returned, otherwise a 2 dimensional
	 *								array is returned. If this sounds confusing,
	 * 								read the source.
	 *
	 * @param bool	$first2cols 	(optional) Means if there are more than
	 *								2 cols, ignore the remaining cols and
	 * 								instead of returning
	 *								array[col0] => array(remaining cols),
	 *								return array[col0] => col1
	 *
	 * @return mixed
	 *
	 */
	public function GetAssoc($force_array = false, $first2cols = false) {
		global $ADODB_EXTENSION;

		$cols = $this->_numOfFields;
		if ($cols < 2) {
			return false;
		}

		// Empty recordset
		if (!$this->fields) {
			return array();
		}

		// Determine whether the array is associative or 0-based numeric
		$numIndex = $this->CheckIfCurrentRowIsNumeric();
		
		if($numIndex === -1)
		{
			ADOConnection::outp("ADORecordSet::GetAssoc(): Overlap of associative and numeric ".
					"keys. Use either ADODB_FETCH_NUM or ADODB_FETCH_ASSOC, or use non numeric ".
					"names for table columns");
			die();
		}

		$results = array();

		if (!$first2cols && ($cols > 2 || $force_array)) {
			if ($ADODB_EXTENSION) {
				if ($numIndex) {
					while (!$this->EOF) {
						$results[trim($this->fields[0])] = array_slice($this->fields, 1);
						adodb_movenext($this);
					}
				} else {
					while (!$this->EOF) {
					// Fix for array_slice re-numbering numeric associative keys
						$keys = array_slice(array_keys($this->fields), 1);
						$sliced_array = array();

						foreach($keys as $key) {
							$sliced_array[$key] = $this->fields[$key];
						}

						$results[trim(reset($this->fields))] = $sliced_array;
						adodb_movenext($this);
					}
				}
			} else {
				if ($numIndex) {
					while (!$this->EOF) {
						$results[trim($this->fields[0])] = array_slice($this->fields, 1);
						$this->MoveNext();
					}
				} else {
					while (!$this->EOF) {
					// Fix for array_slice re-numbering numeric associative keys
						$keys = array_slice(array_keys($this->fields), 1);
						$sliced_array = array();

						foreach($keys as $key) {
							$sliced_array[$key] = $this->fields[$key];
						}

						$results[trim(reset($this->fields))] = $sliced_array;
						$this->MoveNext();
					}
				}
			}
		} else {
			if ($ADODB_EXTENSION) {
				// return scalar values
				if ($numIndex) {
					while (!$this->EOF) {
					// some bug in mssql PHP 4.02 -- doesn't handle references properly so we FORCE creating a new string
						$results[trim(($this->fields[0]))] = $this->fields[1];
						adodb_movenext($this);
					}
				} else {
					while (!$this->EOF) {
					// some bug in mssql PHP 4.02 -- doesn't handle references properly so we FORCE creating a new string
						$v1 = trim(reset($this->fields));
						$v2 = ''.next($this->fields);
						$results[$v1] = $v2;
						adodb_movenext($this);
					}
				}
			} else {
				if ($numIndex) {
					while (!$this->EOF) {
					// some bug in mssql PHP 4.02 -- doesn't handle references properly so we FORCE creating a new string
						$results[trim(($this->fields[0]))] = $this->fields[1];
						$this->MoveNext();
					}
				} else {
					while (!$this->EOF) {
					// some bug in mssql PHP 4.02 -- doesn't handle references properly so we FORCE creating a new string
						$v1 = trim(reset($this->fields));
						$v2 = ''.next($this->fields);
						$results[$v1] = $v2;
						$this->MoveNext();
					}
				}
			}
		}

		$ref = $results; # workaround accelerator incompat with PHP 4.4 :(
		return $ref;
	}

	/**
	 *
	 * @param v		is the character timestamp in YYYY-MM-DD hh:mm:ss format
	 * @param fmt	is the format to apply to it, using date()
	 *
	 * @return a timestamp formatted as user desires
	 */
	public function UserTimeStamp($v,$fmt='Y-m-d H:i:s') {
		if (is_numeric($v) && strlen($v)<14) {
			return adodb_date($fmt,$v);
		}
		$tt = $this->UnixTimeStamp($v);
		// $tt == -1 if pre TIMESTAMP_FIRST_YEAR
		if (($tt === false || $tt == -1) && $v != false) {
			return $v;
		}
		if ($tt === 0) {
			return $this->emptyTimeStamp;
		}
		return adodb_date($fmt,$tt);
	}


	/**
	 * @param v		is the character date in YYYY-MM-DD format, returned by database
	 * @param fmt	is the format to apply to it, using date()
	 *
	 * @return a date formatted as user desires
	 */
	public function UserDate($v,$fmt='Y-m-d') {
		$tt = $this->UnixDate($v);
		// $tt == -1 if pre TIMESTAMP_FIRST_YEAR
		if (($tt === false || $tt == -1) && $v != false) {
			return $v;
		} else if ($tt == 0) {
			return $this->emptyDate;
		} else if ($tt == -1) {
			// pre-TIMESTAMP_FIRST_YEAR
		}
		return adodb_date($fmt,$tt);
	}


	/**
	 * @param $v is a date string in YYYY-MM-DD format
	 *
	 * @return date in unix timestamp format, or 0 if before TIMESTAMP_FIRST_YEAR, or false if invalid date format
	 */
	static function UnixDate($v) {
		return ADOConnection::UnixDate($v);
	}


	/**
	 * @param $v is a timestamp string in YYYY-MM-DD HH-NN-SS format
	 *
	 * @return date in unix timestamp format, or 0 if before TIMESTAMP_FIRST_YEAR, or false if invalid date format
	 */
	static function UnixTimeStamp($v) {
		return ADOConnection::UnixTimeStamp($v);
	}


	/**
	* PEAR DB Compat - do not use internally
	*/
	public function Free() {
		return $this->Close();
	}


	/**
	* PEAR DB compat, number of rows
	*/
	public function NumRows() {
		return $this->_numOfRows;
	}


	/**
	* PEAR DB compat, number of cols
	*/
	public function NumCols() {
		return $this->_numOfFields;
	}

	/**
	* Fetch a row, returning false if no more rows.
	* This is PEAR DB compat mode.
	*
	* @return false or array containing the current record
	*/
	public function FetchRow() {
		if ($this->EOF) {
			return false;
		}
		$arr = $this->fields;
		$this->_currentRow++;
		if (!$this->_callFetch()) {
			$this->EOF = true;
		}
		return $arr;
	}


	/**
	* Fetch a row, returning PEAR_Error if no more rows.
	* This is PEAR DB compat mode.
	*
	* @return DB_OK or error object
	*/
	public function FetchInto(&$arr) {
		if ($this->EOF) {
			return (defined('PEAR_ERROR_RETURN')) ? new PEAR_Error('EOF',-1): false;
		}
		$arr = $this->fields;
		$this->MoveNext();
		return 1; // DB_OK
	}


	/**
	 * Move to the first row in the recordset. Many databases do NOT support this.
	 *
	 * @return true or false
	 */
	protected function _MoveFirst() {
		if ($this->_currentRow == 0) {
			return true;
		}
		return $this->Move(0);
	}
	
	public final function MoveFirst()
	{
		if($this->_isBufferMode)
			{return ADORecordSet::_MoveFirst();}
		else
			{return $this->_MoveFirst();}
	}


	/**
	 * Move to the last row in the recordset.
	 *
	 * @return true or false
	 */
	protected function _MoveLast() {
		if ($this->_numOfRows >= 0) {
			return $this->Move($this->_numOfRows-1);
		}
		if ($this->EOF) {
			return false;
		}
		while (!$this->EOF) {
			$f = $this->fields;
			$this->MoveNext();
		}
		$this->fields = $f;
		$this->EOF = false;
		return true;
	}

	public final function MoveLast()
	{
		if($this->_isBufferMode)
			{return ADORecordSet::_MoveLast();}
		else
			{return $this->_MoveLast();}
	}


	/**
	 * Move to next record in the recordset.
	 *
	 * @return true if there still rows available, or false if there are no more rows (EOF).
	 */
	protected function _MoveNext() {
		if (!$this->EOF) {
			$this->_currentRow++;
			if ($this->_callFetch()) {
				return true;
			}
		}
		$this->EOF = true;
		/* -- tested error handling when scrolling cursor -- seems useless.
		$conn = $this->connection;
		if ($conn && $conn->raiseErrorFn && ($errno = $conn->ErrorNo())) {
			$fn = $conn->raiseErrorFn;
			$fn($conn->databaseType,'MOVENEXT',$errno,$conn->ErrorMsg().' ('.$this->sql.')',$conn->host,$conn->database);
		}
		*/
		return false;
	}

	public final function MoveNext()
	{
		if($this->_isBufferMode)
		{
			if (!$this->EOF) {
				$this->_currentRow++;

				$pos = $this->_currentRow;

				if ($this->_numOfRows <= $pos) {
					if (!$this->compat) {
						$this->fields = false;
					}
				} else {
					$this->fields = $this->_array[$pos];
					return true;
				}
				$this->EOF = true;
			}

			return false;
		}
		else
			{return $this->_MoveNext();}
	}

	/**
	 * Random access to a specific row in the recordset. Some databases do not support
	 * access to previous rows in the databases (no scrolling backwards).
	 *
	 * @param rowNumber is the row to move to (0-based)
	 *
	 * @return true if there still rows available, or false if there are no more rows (EOF).
	 */
	public function Move($rowNumber = 0) {
		$this->EOF = false;
		if ($rowNumber == $this->_currentRow) {
			return true;
		}
		if ($rowNumber >= $this->_numOfRows) {
			if ($this->_numOfRows != -1) {
				$rowNumber = $this->_numOfRows-2;
			}
		}

		if ($rowNumber < 0) {
			$this->EOF = true;
			return false;
		}

		if ($this->canSeek) {
			if ($this->_callSeek($rowNumber)) {
				$this->_currentRow = $rowNumber;
				if ($this->_callFetch()) {
					return true;
				}
			} else {
				$this->EOF = true;
				return false;
			}
		} else {
			if ($rowNumber < $this->_currentRow) {
				return false;
			}
			global $ADODB_EXTENSION;
			if ($ADODB_EXTENSION) {
				while (!$this->EOF && $this->_currentRow < $rowNumber) {
					adodb_movenext($this);
				}
			} else {
				while (! $this->EOF && $this->_currentRow < $rowNumber) {
					$this->_currentRow++;

					if (!$this->_callFetch()) {
						$this->EOF = true;
					}
				}
			}
			return !($this->EOF);
		}

		$this->fields = false;
		$this->EOF = true;
		return false;
	}


	/**
	 * Get the value of a field in the current row by column name.
	 * Might not work if ADODB_FETCH_MODE is set to ADODB_FETCH_NUM.
	 * 
	 * Warning: This is the default implementation which assumes the driver
	 *		supports ADODB_FETCH_ASSOC mode natively, or emulated. Drivers
	 *		that offer no support at all must override this function.
	 *
	 * @param colname  is the field to access
	 *
	 * @return the value of $colname column
	 */
	public function Fields($colname) {
		GetAssocKeys();

		return @$this->fields[$this->bind[strtoupper($colname)]];
	}

	/**
	 * Builds the bind array associating keys to recordset fields
	 *
	 */
	protected function GetAssocKeys() {
		if ($this->bind) {
			return;
		}
		$this->bind = array();
		
		if(!($this->fetchMode & ADODB_FETCH_ASSOC))
		{
			for ($i=0; $i < $this->_numOfFields; $i++) {
				$o = $this->FetchField($i);
				$this->bind[strtoupper($o->name)] = $i;
				$this->fromBindKeysToColumnNames[strtoupper($o->name)] = $o->name;
			}
		}
		else
		{
			if($this->fetchMode == ADODB_FETCH_ASSOC)
			{
				foreach ($this->fields as $tKey => $tValue) {
					$this->bind[strtoupper($tKey)] = $tKey;
					$this->fromBindKeysToColumnNames[strtoupper($tKey)] = $tKey;
				}
			}
			else
			{
				foreach($this->fields as $tKey => $tValue)
				{
					if(!(ctype_digit(trim($tKey)) && ($tKey >= 0) &&
							($tKey < $this->_numOfFields)))
					{
						$this->bind[strtoupper($tKey)] = $tKey;
						$this->fromBindKeysToColumnNames[strtoupper($tKey)] = $tKey;
					}
				}

				if(count($this->bind) != $this->_numOfFields)
				{
					ADOConnection::outp("ADORecordSet::GetAssocKeys(): Overlap of ".
							"associative and numeric keys. Use either ADODB_FETCH_NUM or ".
							"ADODB_FETCH_ASSOC, or use non numeric names for table columns");
					die();
				}
			}
		}
	}

	/**
	 * Use associative array to get fields array for databases that do not support
	 * associative arrays. Submitted by Paolo S. Asioli paolo.asioli#libero.it
	 *
	 * @param int $upper Case for the array keys, defaults to uppercase
	 *                   (see ADODB_ASSOC_CASE_xxx constants)
	 */
	public function GetRowAssoc($upper = ADODB_ASSOC_CASE_UPPER) {
		$record = array();
		$this->GetAssocKeys();

		foreach($this->bind as $k => $v) {
			if( array_key_exists( $v, $this->fields ) ) {
				$record[$this->fromBindKeysToColumnNames[$k]] = $this->fields[$v];
			} else {
				# This should not happen... trigger error ?
				$record[$this->fromBindKeysToColumnNames[$k]] = null;
			}
		}

		if($upper != ADODB_ASSOC_CASE_NATIVE)
		{
			if($upper == ADODB_ASSOC_CASE_UPPER)
				{return array_change_key_case($record, CASE_UPPER);}
			else
				{return array_change_key_case($record, CASE_LOWER);}
		}
		return $record;
	}

	/**
	 * Warning: to be used by drivers only, those that offer emulated support for the
	 * 	associative fetch mode.
	 *
	 * Use associative array to get fields array for databases that do not support
	 * associative arrays. With credit to Paolo S. Asioli paolo.asioli#libero.it
	 * Will also rebuild the bind array associating keys to recordset fields regardless of its
	 * state. This is because it assumes its output will be used to rebuild $fields.
	 *
	 *
	 */
	protected function GetEmulatedRowAssoc()
	{
		$record = array();
		
		$this->bind = array();		
		for ($i=0; $i < $this->_numOfFields; $i++) {
			$o = $this->FetchField($i);
			$this->bind[strtoupper($o->name)] = $i;
			$this->fromBindKeysToColumnNames[strtoupper($o->name)] = $o->name;
		}

		foreach($this->bind as $k => $v) {
			if( array_key_exists( $v, $this->fields ) ) {
				$record[$this->fromBindKeysToColumnNames[$k]] = $this->fields[$v];
				$this->bind[$k] = $this->fromBindKeysToColumnNames[$k];
			} else {
				# This should not happen... trigger error ?
				$record[$this->fromBindKeysToColumnNames[$k]] = null;
			}
		}
		return $record;
	}

	/**
	 * Clean up recordset
	 *
	 * @return true or false
	 */
	public function Close() {
		// free resource object - this seems to globally free the object
		// and not merely the reference, so don't do this...
		// $this->_queryID = false;
		if ($this->_queryID) {
			$tReturn = $this->_close();

			$this->_queryID = false;

			return $tReturn;
		} else
			return true;
	}

	/**
	 * synonyms RecordCount and RowCount
	 *
	 * @return the number of rows or -1 if this is not supported
	 */
	public function RecordCount() {
		return $this->_numOfRows;
	}


	/*
	* If we are using PageExecute(), this will return the maximum possible rows
	* that can be returned when paging a recordset.
	*/
	public function MaxRecordCount() {
		return ($this->_maxRecordCount) ? $this->_maxRecordCount : $this->RecordCount();
	}

	/**
	 * synonyms RecordCount and RowCount
	 *
	 * @return the number of rows or -1 if this is not supported
	 */
	public function RowCount() {
		return $this->_numOfRows;
	}


	 /**
	 * Portable RecordCount. Pablo Roca <pabloroca@mvps.org>
	 *
	 * @return  the number of records from a previous SELECT. All databases support this.
	 *
	 * But aware possible problems in multiuser environments. For better speed the table
	 * must be indexed by the condition. Heavy test this before deploying.
	 */
	public function PO_RecordCount($table="", $condition="") {

		$lnumrows = $this->_numOfRows;
		// the database doesn't support native recordcount, so we do a workaround
		if ($lnumrows == -1 && $this->connection) {
			IF ($table) {
				if ($condition) {
					$condition = " WHERE " . $condition;
				}
				$resultrows = $this->connection->Execute("SELECT COUNT(*) FROM $table $condition");
				if ($resultrows) {
					$lnumrows = reset($resultrows->fields);
				}
			}
		}
		return $lnumrows;
	}


	/**
	 * @return the current row in the recordset. If at EOF, will return the last row. 0-based.
	 */
	public function CurrentRow() {
		return $this->_currentRow;
	}

	/**
	 * synonym for CurrentRow -- for ADO compat
	 *
	 * @return the current row in the recordset. If at EOF, will return the last row. 0-based.
	 */
	public function AbsolutePosition() {
		return $this->_currentRow;
	}

	/**
	 * @return the number of columns in the recordset. Some databases will set this to 0
	 * if no records are returned, others will return the number of columns in the query.
	 */
	public function FieldCount() {
		return $this->_numOfFields;
	}


	/**
	 * Get the ADOFieldObject of a specific column.
	 *
	 * @param fieldoffset	is the column position to access(0-based). The field is optional but for some drivers only with differing behavior.
	 *
	 * @return the ADOFieldObject for that column, or false.
	 */
	protected function _FetchField($fieldoffset = -1) {
		// must be defined by child class

		return false;
	}

	public final function FetchField($fieldoffset = -1)
	{
		if($this->_isBufferMode)
			{return $this->_FetchField__bufferMode($fieldoffset);}
		else
		{
			if(($fieldoffset !== -1))
			{
				if($this->_fieldobjects === NULL)
					{$this->_fieldobjects = array();}

				if(!array_key_exists($fieldoffset, $this->_fieldobjects))
					{$this->_fieldobjects[$fieldoffset] = $this->_FetchField($fieldoffset);}
				
				return $this->_fieldobjects[$fieldoffset];
			}
			else
				{return $this->_FetchField(-1);}	//Drivers behave inconsistently in this case, and thus it is 
													//		their responsibility to fill $this->_fieldobjects
		}
	}

	protected function _FetchField__bufferMode($fieldoffset = -1)
		{return $this->_fieldobjects[$fieldoffset];}

	/**
	 * Get the ADOFieldObjects of all columns in an array.
	 *
	 */
	public function FieldTypesArray() {
		static $arr = array();
		if (empty($arr)) {
			for ($i=0, $max=$this->_numOfFields; $i < $max; $i++) {
				$arr[] = $this->FetchField($i);
			}
		}
		return $arr;
	}

	/**
	* Return the fields array of the current row as an object for convenience.
	* The default case is lowercase field names.
	*
	* @return the object with the properties set to the fields of the current row
	*/
	public function FetchObj() {
		$o = $this->FetchObject(false);
		return $o;
	}

	/**
	* Return the fields array of the current row as an object for convenience.
	* The default case is uppercase.
	*
	* @param $isupper to set the object property names to uppercase
	*
	* @return the object with the properties set to the fields of the current row
	*/
	public function FetchObject($isupper=true) {
		if (empty($this->_obj)) {
			$this->_obj = new ADOFetchObj();
			$this->_names = array();
			for ($i=0; $i <$this->_numOfFields; $i++) {
				$f = $this->FetchField($i);
				$this->_names[] = $f->name;
			}
		}
		$i = 0;
		$o = clone($this->_obj);

		for ($i=0; $i <$this->_numOfFields; $i++) {
			$name = $this->_names[$i];
			if ($isupper) {
				$n = strtoupper($name);
			} else {
				$n = $name;
			}

			$o->$n = $this->Fields($name);
		}
		return $o;
	}

	/**
	* Return the fields array of the current row as an object for convenience.
	* The default is lower-case field names.
	*
	* @return the object with the properties set to the fields of the current row,
	*	or false if EOF
	*
	* Fixed bug reported by tim@orotech.net
	*/
	public function FetchNextObj() {
		$o = $this->FetchNextObject(false);
		return $o;
	}


	/**
	* Return the fields array of the current row as an object for convenience.
	* The default is upper case field names.
	*
	* @param $isupper to set the object property names to uppercase
	*
	* @return the object with the properties set to the fields of the current row,
	*	or false if EOF
	*
	* Fixed bug reported by tim@orotech.net
	*/
	public function FetchNextObject($isupper=true) {
		$o = false;
		if ($this->_numOfRows != 0 && !$this->EOF) {
			$o = $this->FetchObject($isupper);
			$this->_currentRow++;
			if ($this->_callFetch()) {
				return $o;
			}
		}
		$this->EOF = true;
		return $o;
	}

	/**
	 * Get the metatype of the column. This is used for formatting. This is because
	 * many databases use different names for the same type, so we transform the original
	 * type to our standardised version which uses 1 character codes:
	 *
	 * @param t  is the type passed in. Normally is ADOFieldObject->type.
	 * @param len is the maximum length of that field. This is because we treat character
	 *	fields bigger than a certain size as a 'B' (blob).
	 * @param fieldobj is the field object returned by the database driver. Can hold
	 *	additional info (eg. primary_key for mysql).
	 *
	 * @return the general type of the data:
	 *	C for character < 250 chars
	 *	X for teXt (>= 250 chars)
	 *	B for Binary
	 *	N for numeric or floating point
	 *	D for date
	 *	T for timestamp
	 *	L for logical/Boolean
	 *	I for integer
	 *	R for autoincrement counter/integer
	 *
	 *
	*/
	public function MetaType($t,$len=-1,$fieldobj=false) {
		if (is_object($t)) {
			$fieldobj = $t;
			$t = $fieldobj->type;
			$len = $fieldobj->max_length;
		}


		// changed in 2.32 to hashing instead of switch stmt for speed...
		static $typeMap = array(
			'VARCHAR' => 'C',
			'VARCHAR2' => 'C',
			'CHAR' => 'C',
			'C' => 'C',
			'STRING' => 'C',
			'NCHAR' => 'C',
			'NVARCHAR' => 'C',
			'VARYING' => 'C',
			'BPCHAR' => 'C',
			'CHARACTER' => 'C',
			'INTERVAL' => 'C',  # Postgres
			'MACADDR' => 'C', # postgres
			'VAR_STRING' => 'C', # mysql
			##
			'LONGCHAR' => 'X',
			'TEXT' => 'X',
			'NTEXT' => 'X',
			'M' => 'X',
			'X' => 'X',
			'CLOB' => 'X',
			'NCLOB' => 'X',
			'LVARCHAR' => 'X',
			##
			'BLOB' => 'B',
			'IMAGE' => 'B',
			'BINARY' => 'B',
			'VARBINARY' => 'B',
			'LONGBINARY' => 'B',
			'B' => 'B',
			##
			'YEAR' => 'D', // mysql
			'DATE' => 'D',
			'D' => 'D',
			##
			'UNIQUEIDENTIFIER' => 'C', # MS SQL Server
			##
			'SMALLDATETIME' => 'T',
			'TIME' => 'T',
			'TIMESTAMP' => 'T',
			'DATETIME' => 'T',
			'DATETIME2' => 'T',
			'TIMESTAMPTZ' => 'T',
			'T' => 'T',
			'TIMESTAMP WITHOUT TIME ZONE' => 'T', // postgresql
			##
			'BOOL' => 'L',
			'BOOLEAN' => 'L',
			'BIT' => 'L',
			'L' => 'L',
			##
			'COUNTER' => 'R',
			'R' => 'R',
			'SERIAL' => 'R', // ifx
			'INT IDENTITY' => 'R',
			##
			'INT' => 'I',
			'INT2' => 'I',
			'INT4' => 'I',
			'INT8' => 'I',
			'INTEGER' => 'I',
			'INTEGER UNSIGNED' => 'I',
			'SHORT' => 'I',
			'TINYINT' => 'I',
			'SMALLINT' => 'I',
			'I' => 'I',
			##
			'LONG' => 'N', // interbase is numeric, oci8 is blob
			'BIGINT' => 'N', // this is bigger than PHP 32-bit integers
			'DECIMAL' => 'N',
			'DEC' => 'N',
			'REAL' => 'N',
			'DOUBLE' => 'N',
			'DOUBLE PRECISION' => 'N',
			'SMALLFLOAT' => 'N',
			'FLOAT' => 'N',
			'NUMBER' => 'N',
			'NUM' => 'N',
			'NUMERIC' => 'N',
			'MONEY' => 'N',

			## informix 9.2
			'SQLINT' => 'I',
			'SQLSERIAL' => 'I',
			'SQLSMINT' => 'I',
			'SQLSMFLOAT' => 'N',
			'SQLFLOAT' => 'N',
			'SQLMONEY' => 'N',
			'SQLDECIMAL' => 'N',
			'SQLDATE' => 'D',
			'SQLVCHAR' => 'C',
			'SQLCHAR' => 'C',
			'SQLDTIME' => 'T',
			'SQLINTERVAL' => 'N',
			'SQLBYTES' => 'B',
			'SQLTEXT' => 'X',
			## informix 10
			"SQLINT8" => 'I8',
			"SQLSERIAL8" => 'I8',
			"SQLNCHAR" => 'C',
			"SQLNVCHAR" => 'C',
			"SQLLVARCHAR" => 'X',
			"SQLBOOL" => 'L'
		);


		$tmap = false;
		$t = strtoupper($t);
		$tmap = (isset($typeMap[$t])) ? $typeMap[$t] : ADODB_DEFAULT_METATYPE;
		switch ($tmap) {
			case 'C':
				// is the char field is too long, return as text field...
				if ($this->blobSize >= 0) {
					if ($len > $this->blobSize) {
						return 'X';
					}
				} else if ($len > 250) {
					return 'X';
				}
				return 'C';

			case 'I':
				if (!empty($fieldobj->primary_key)) {
					return 'R';
				}
				return 'I';

			case false:
				return 'N';

			case 'B':
				if (isset($fieldobj->binary)) {
					return ($fieldobj->binary) ? 'B' : 'X';
				}
				return 'B';

			case 'D':
				if (!empty($this->connection) && !empty($this->connection->datetime)) {
					return 'T';
				}
				return 'D';

			default:
				if ($t == 'LONG' && $this->dataProvider == 'oci8') {
					return 'B';
				}
				return $tmap;
		}
	}

	protected function _close() {}

	/**
	 * set/returns the current recordset page when paginating
	 */
	public function AbsolutePage($page=-1) {
		if ($page != -1) {
			$this->_currentPage = $page;
		}
		return $this->_currentPage;
	}

	/**
	 * set/returns the status of the atFirstPage flag when paginating
	 */
	public function AtFirstPage($status=false) {
		if ($status != false) {
			$this->_atFirstPage = $status;
		}
		return $this->_atFirstPage;
	}

	public function LastPageNo($page = false) {
		if ($page != false) {
			$this->_lastPageNo = $page;
		}
		return $this->_lastPageNo;
	}

	/**
	 * set/returns the status of the atLastPage flag when paginating
	 */
	public function AtLastPage($status=false) {
		if ($status != false) {
			$this->_atLastPage = $status;
		}
		return $this->_atLastPage;
	}

	/**
	 * returns 1 if current row is at least numericaly indexed. 0, if associative. -1, if
	 *			associative and numeric keys overlap.
	 */
	public function CheckIfCurrentRowIsNumeric()
	{
		if(($this->fetchMode === ADODB_FETCH_NUM) || 
				($this->fetchMode === ADODB_FETCH_ASSOC))
			{return ($this->fetchMode === ADODB_FETCH_NUM);}

		$vAssociativeKeys = array();
		$vNumericKeys = array();
		$vAssociativeSubset = array();
		$vNumericSubset = array();
		$vAssociativeKeysCount = -1;
		$vNumericKeysCount = -1;

		foreach($this->fields as $tKey => $tValue)
		{
			if(ctype_digit(trim($tKey)) && ($tKey >= 0) &&
					($tKey < $this->_numOfFields))
			{
				$vNumericKeys[] = $tKey;
				$vNumericSubset[$tValue] = $tValue;
			}
			else
			{
				$vAssociativeKeys[] = $tKey;
				$vAssociativeSubset[$tValue] = $tValue;
			}
		}

		$vAssociativeKeysCount = count($vAssociativeKeys);
		$vNumericKeysCount = count($vNumericKeys);

		if($vNumericKeysCount === $this->_numOfFields)
		{
			if($vNumericKeysCount === $vAssociativeKeysCount)
				{return 1;}
			else
				{return -1;}
		}
		else
			{return 0;}
	}

	protected function ReInit()
	{
		$this->_inited = false;
		$this->_currentRow = -1;
		$this->bind = false;
		$this->Init();
	}

	/**
	 *	Turns the record set to the equivilant to what used to be an instance of ADORecordSet_array. This
	 *		essentially pre fetches the entierty of the record. The record set is then closed unless $close
	 *		is set to false. This is useful on databases that support ADORecordSet::NextRecordSet(). When this
	 *		function is called, the instance switches to buffer mode, but when ADORecordSet::NextRecordSet() is
	 *		called the instance would switch back to normal mode, and hence, this function must be called again. 
	 *		If $close was not set to false, a future call to ADORecordSet::NextRecordSet() would be unsuccesful
	 *
	 *	
	 *
	*/
	public final function SwitchToBufferMode($nrows=-1, $offset=-1, $close=true)
	{
		if($this->_isBufferMode)
			{return false;}

		global $ADODB_COMPAT_FETCH;
		$vFields = array();
		$vFieldCount = $this->FieldCount();
		$vData = null;

		$this->canSeek = true;
		$this->compat = !empty($ADODB_COMPAT_FETCH);


		for($tI = 0; $tI < $vFieldCount; $tI++)
			{$vFields[] = $this->FetchField($tI);}

		$this->_array = $this->GetArrayLimit($nrows,$offset);
		if($vFields)
			{$this->_fieldobjects = $vFields;}

		if($close)
			{$this->Close();}
		$this->_isBufferMode = true;
		$this->ReInit();

		return true;
	}

	/**
	 * Initializes record set with data passed through $pDataArray, and closes the record set resource if there is
	 *		one.
	 *
	 * @param pDataArray	Contains the data necessary to fill the record set. The structure is as follows:
	 *		pDataArray["fetchMode"]: (optional) contains the fetch mode used to retrieve the data originally. The
	 *				value should be one of the ADODB_FETCH_xxx constants. If not set, the value of $ADODB_FETCH_MODE
	 *				is assumed. It is highly recommended that this be explicitly set. Things are kept this way for
	 *				the time being for backward compatibility with the rest of the library. The field is likely
	 *				to become mandatory in the future.
	 *		pDataArray["columnNames"]: An array containing the corresponding column
	 *				names of the data. The field is ignored if $pADOFieldObjects is set, and is mandatory otherwise
	 *		pDataArray["columnTypes"]: An array containing the corresponding types of the data. The types are
	 *				defined with values understandable by ADORecordSet::MetaType().The field is ignored if $pADOFieldObjects
	 *				is set, and is mandatory otherwise
	 *		pDataArray["columnMaxLength"]: (optional) An array containing the corresponding column max length. The field is 
	 *		ignored if $pADOFieldObjects is set.
	 *		pDataArray["recordSets"]: (mandatory) A numerically indexed array of arrays, where each array contains a
	 *				single record set. This is for databases that can return multiple record sets. See 
	 *				ADORecordSet::NextRecordSet() for clarification. Currently the multi record set functionality
	 *				when in buffer mode is not operational, and hence the only value that should exist is
	 *				pDataArray["data"][0]
	 * @param pADOFieldObjects	Contains an array of instances of ADOFieldObject corresponding to each data column.
	 */
	public function InitializeBufferWith($pDataArray, $pADOFieldObjects = NULL)
	{
		global $ADODB_FETCH_MODE;

		$this->canSeek = true;
		$this->compat = !empty($ADODB_COMPAT_FETCH);

		$this->fetchMode = ((array_key_exists("fetchMode", $pDataArray) && ($pDataArray["fetchMode"] !== false)) ? 
				$pDataArray["fetchMode"] : $ADODB_FETCH_MODE);

		if($pADOFieldObjects !== NULL)
			{$this->_fieldobjects = $pADOFieldObjects;}
		else
		{
			$tIsColumnMaxLengthSet = isset($pDataArray["columnMaxLength"]);

			$this->_fieldobjects = array();

			for($tI = 0; $tI < count($pDataArray["recordSets"][0][0]); $tI++)
			{
				$tADOFieldObject = new ADOFieldObject();

				$tADOFieldObject->name = $pDataArray["columnNames"][$tI];
				$tADOFieldObject->type = $pDataArray["columnTypes"][$tI];
				$tADOFieldObject->max_length = ($tIsColumnMaxLengthSet ? $pDataArray["columnMaxLength"][$tI] :
						-1);

				$this->_fieldobjects[$tI] = $tADOFieldObject;
			}
		}
		$this->_array = $pDataArray["recordSets"][0];

		$this->Close();
		$this->_isBufferMode = true;
		$this->ReInit();
	}

	// For backward compatibility only. Do not use. Refer to the old ADORecordSet_array::InitArray()
	public final function InitArray($pData, $pTypes, $pColumnNames = false)
	{
		$vDataArray = array();

		$vDataArray["recordSets"] = array();
		$vDataArray["columnTypes"] = $pTypes;		

		if($pColumnNames)
		{
			$vDataArray["columnNames"] = $pColumnNames;
			$vDataArray["recordSets"][0] = $pData;
		}
		else
		{
			$vDataArray["columnNames"] = array_shift($pData);
			$vDataArray["recordSets"][0] = $pData;
		}

		return $this->InitializeBufferWith($vDataArray);
	}

	// For backward compatibility only. Do not use. Refer to the old ADORecordSet_array::InitArrayFields()
	public final function InitArrayFields(&$pData, &$pADOFieldObjects)
	{
		$vDataArray = array();

		$vDataArray["recordSets"] = array();

		$vDataArray["recordSets"][0] = $pData;

		return $this->InitializeBufferWith($vDataArray, $pADOFieldObjects);
	}
	
	public function Transpose($addfieldnames=true) {
		global $ADODB_INCLUDED_LIB;
		$vTypes = true;

		$this->SwitchToBufferMode();

		if (empty($ADODB_INCLUDED_LIB)) {
			include(ADODB_DIR.'/adodb-lib.inc.php');
		}
		$hdr = true;

		$fobjs = $addfieldnames ? $this->_fieldobjects : false;
		adodb_transpose($this->_array, $newarr, $hdr, $fobjs);
		//adodb_pr($newarr);

		$this->_array = $newarr;

		adodb_probetypes($newarr,$vTypes);

		$this->_fieldobjects = array();

		foreach($hdr as $k => $name) {
			$f = new ADOFieldObject();
			$f->name = $name;
			$f->type = $vTypes[$k];
			$f->max_length = -1;
			$this->_fieldobjects[] = $f;
		}
		$this->fields = reset($this->_array);

		$this->_initrs();

	}
} // end class ADORecordSet

	//==============================================================================================
	// CLASS ADORecordSet_array
	//==============================================================================================

	/**
	 * This class encapsulates the concept of a recordset created in memory
	 * as an array. This is useful for the creation of cached recordsets.
	 *
	 * Note that the constructor is different from the standard ADORecordSet
	 */
	class ADORecordSet_array extends ADORecordSet
	{
		/*public  $databaseType = 'array';

		protected  $_array;	// holds the 2-dimensional data array
		protected  $_types;	// the array of types of each column (C B I L M)
		protected  $_colnames;	// names of each column in array
		protected  $_skiprow1;	// skip 1st row because it holds column names
		protected  $_fieldobjects; // holds array of field objects
		public  $canSeek = true;
		public  $affectedrows = false;
		public  $insertid = false;
		public  $sql = '';
		public  $compat = false;*/

		/**
		 * Constructor
		 */
		public function __construct($fakeid=false, $mode=false) {
			/*global $ADODB_FETCH_MODE,$ADODB_COMPAT_FETCH;

			// fetch() on EOF does not delete $this->fields
			$this->compat = !empty($ADODB_COMPAT_FETCH);*/
			parent::__construct($fakeid, $mode); // fake queryID.
		}

		/*public function _transpose($addfieldnames=true) {
			global $ADODB_INCLUDED_LIB;

			if (empty($ADODB_INCLUDED_LIB)) {
				include_once(ADODB_DIR.'/adodb-lib.inc.php');
			}
			$hdr = true;

			$fobjs = $addfieldnames ? $this->_fieldobjects : false;
			adodb_transpose($this->_array, $newarr, $hdr, $fobjs);
			//adodb_pr($newarr);

			$this->_skiprow1 = false;
			$this->_array = $newarr;
			$this->_colnames = $hdr;

			adodb_probetypes($newarr,$this->_types);

			$this->_fieldobjects = array();

			foreach($hdr as $k => $name) {
				$f = new ADOFieldObject();
				$f->name = $name;
				$f->type = $this->_types[$k];
				$f->max_length = -1;
				$this->_fieldobjects[] = $f;
			}
			$this->fields = reset($this->_array);

			$this->_initrs();

		}*/

		/**
		 * Setup the array.
		 *
		 * @param array		is a 2-dimensional array holding the data.
		 *			The first row should hold the column names
		 *			unless parameter $colnames is used.
		 * @param typearr	holds an array of types. These are the same types
		 *			used in MetaTypes (C,B,L,I,N).
		 * @param [colnames]	array of column names. If set, then the first row of
		 *			$array should not hold the column names.
		 */
		/*public function InitArray($array,$typearr,$colnames=false) {
			$this->_array = $array;
			$this->_types = $typearr;
			if ($colnames) {
				$this->_skiprow1 = false;
				$this->_colnames = $colnames;
			} else {
				$this->_skiprow1 = true;
				$this->_colnames = $array[0];
			}
			$this->Init();
		}*/
		/**
		 * Setup the Array and datatype file objects
		 *
		 * @param array		is a 2-dimensional array holding the data.
		 *			The first row should hold the column names
		 *			unless parameter $colnames is used.
		 * @param fieldarr	holds an array of ADOFieldObject's.
		 */
		/*public function InitArrayFields(&$array,&$fieldarr) {
			$this->_array = $array;
			$this->_skiprow1= false;
			if ($fieldarr) {
				$this->_fieldobjects = $fieldarr;
			}
			$this->Init();
		}*/

		/*public function GetArray($nRows=-1) {
			if ($nRows == -1 && $this->_currentRow <= 0 && !$this->_skiprow1) {
				return $this->_array;
			} else {
				$arr = ADORecordSet::GetArray($nRows);
				return $arr;
			}
		}*/

		/*protected function _initrs() {
			$this->_numOfRows =  sizeof($this->_array);
			if ($this->_skiprow1) {
				$this->_numOfRows -= 1;
			}

			$this->_numOfFields = (isset($this->_fieldobjects))
				? sizeof($this->_fieldobjects)
				: sizeof($this->_types);
		}*/

		/* Use associative array to get fields array */
		/*public function Fields($colname) {
			$mode = $this->fetchMode;

			if ($mode & ADODB_FETCH_ASSOC) {
				if (!isset($this->fields[$colname]) && !is_null($this->fields[$colname])) {
					$colname = strtolower($colname);
				}
				return $this->fields[$colname];
			}
			if (!$this->bind) {
				$this->bind = array();
				for ($i=0; $i < $this->_numOfFields; $i++) {
					$o = $this->FetchField($i);
					$this->bind[strtoupper($o->name)] = $i;
				}
			}
			return $this->fields[$this->bind[strtoupper($colname)]];
		}*/

		/*public function FetchField($fieldOffset = -1) {
			if (isset($this->_fieldobjects)) {
				return $this->_fieldobjects[$fieldOffset];
			}
			$o =  new ADOFieldObject();
			$o->name = $this->_colnames[$fieldOffset];
			$o->type =  $this->_types[$fieldOffset];
			$o->max_length = -1; // length not known

			return $o;
		}*/

		/*protected function _seek($row) {
			if (sizeof($this->_array) && 0 <= $row && $row < $this->_numOfRows) {
				$this->_currentRow = $row;
				if ($this->_skiprow1) {
					$row += 1;
				}
				$this->fields = $this->_array[$row];
				return true;
			}
			return false;
		}*/

		/*public function MoveNext() {
			if (!$this->EOF) {
				$this->_currentRow++;

				$pos = $this->_currentRow;

				if ($this->_numOfRows <= $pos) {
					if (!$this->compat) {
						$this->fields = false;
					}
				} else {
					if ($this->_skiprow1) {
						$pos += 1;
					}
					$this->fields = $this->_array[$pos];
					return true;
				}
				$this->EOF = true;
			}

			return false;
		}*/

		/*protected function _fetch() {
			$pos = $this->_currentRow;

			if ($this->_numOfRows <= $pos) {
				if (!$this->compat) {
					$this->fields = false;
				}
				return false;
			}
			if ($this->_skiprow1) {
				$pos += 1;
			}
			$this->fields = $this->_array[$pos];
			return true;
		}*/

		/*protected function _close() {
			return true;
		}*/

	} // ADORecordSet_array

	//==============================================================================================
	// HELPER FUNCTIONS
	//==============================================================================================

	/**
	 * Synonym for ADOLoadCode. Private function. Do not use.
	 *
	 * @deprecated
	 */
	function ADOLoadDB($dbType) {
		return ADOLoadCode($dbType);
	}

	/**
	 * Load the code for a specific database driver. Private function. Do not use.
	 */
	function ADOLoadCode($dbType) {
		global $ADODB_LASTDB;

		if (!$dbType) {
			return false;
		}
		$db = strtolower($dbType);
		switch ($db) {
			case 'ado':
				$db = 'ado5';
				$class = 'ado';
				break;

			case 'ifx':
			case 'maxsql':
			case 'mysqlpo':
				$class = $db = 'mysqlt';
				break;

			case 'pgsql':
			case 'postgres':
				$class = $db = 'postgres9';
				break;

			default:
				$class = $db;
				break;
		}

		$file = "drivers/adodb-$db.inc.php";
		include_once(ADODB_DIR . '/' . $file);
		$ADODB_LASTDB = $class;
		if (class_exists("ADODB_" . $class)) {
			return $class;
		}

		//ADOConnection::outp(adodb_pr(get_declared_classes(),true));
		if (!file_exists(ADODB_DIR . '/' . $file)) {
			ADOConnection::outp("Missing file: $file");
		} else {
			ADOConnection::outp("Syntax error in file: $file");
		}
		return false;
	}

	/**
	 * synonym for ADONewConnection for people like me who cannot remember the correct name
	 */
	function NewADOConnection($db='') {
		$tmp = ADONewConnection($db);
		return $tmp;
	}

	/**
	 * Instantiate a new Connection class for a specific database driver.
	 *
	 * @param [db]  is the database Connection object to create. If undefined,
	 *	use the last database driver that was loaded by ADOLoadCode().
	 *
	 * @return ADOConnection|false The freshly created instance of the Connection class
	 *                             or false in case of error.
	 */
	function ADONewConnection($db='') {
		global $ADODB_NEWCONNECTION, $ADODB_LASTDB;

		$errorfn = (defined('ADODB_ERROR_HANDLER')) ? ADODB_ERROR_HANDLER : false;
		if (($at = strpos($db,'://')) !== FALSE) {
			$origdsn = $db;
			$fakedsn = 'fake'.substr($origdsn,$at);
			if (($at2 = strpos($origdsn,'@/')) !== FALSE) {
				// special handling of oracle, which might not have host
				$fakedsn = str_replace('@/','@adodb-fakehost/',$fakedsn);
			}

			if ((strpos($origdsn, 'sqlite')) !== FALSE && stripos($origdsn, '%2F') === FALSE) {
				// special handling for SQLite, it only might have the path to the database file.
				// If you try to connect to a SQLite database using a dsn
				// like 'sqlite:///path/to/database', the 'parse_url' php function
				// will throw you an exception with a message such as "unable to parse url"
				list($scheme, $path) = explode('://', $origdsn);
				$dsna['scheme'] = $scheme;
				if ($qmark = strpos($path,'?')) {
					$dsn['query'] = substr($path,$qmark+1);
					$path = substr($path,0,$qmark);
				}
				$dsna['path'] = '/' . urlencode($path);
			} else
				$dsna = @parse_url($fakedsn);

			if (!$dsna) {
				return false;
			}
			$dsna['scheme'] = substr($origdsn,0,$at);
			if ($at2 !== FALSE) {
				$dsna['host'] = '';
			}

			if (strncmp($origdsn,'pdo',3) == 0) {
				$sch = explode('_',$dsna['scheme']);
				if (sizeof($sch)>1) {
					$dsna['host'] = isset($dsna['host']) ? rawurldecode($dsna['host']) : '';
					if ($sch[1] == 'sqlite') {
						$dsna['host'] = rawurlencode($sch[1].':'.rawurldecode($dsna['host']));
					} else {
						$dsna['host'] = rawurlencode($sch[1].':host='.rawurldecode($dsna['host']));
					}
					$dsna['scheme'] = 'pdo';
				}
			}

			$db = @$dsna['scheme'];
			if (!$db) {
				return false;
			}
			$dsna['host'] = isset($dsna['host']) ? rawurldecode($dsna['host']) : '';
			$dsna['user'] = isset($dsna['user']) ? rawurldecode($dsna['user']) : '';
			$dsna['pass'] = isset($dsna['pass']) ? rawurldecode($dsna['pass']) : '';
			$dsna['path'] = isset($dsna['path']) ? rawurldecode(substr($dsna['path'],1)) : ''; # strip off initial /

			if (isset($dsna['query'])) {
				$opt1 = explode('&',$dsna['query']);
				foreach($opt1 as $k => $v) {
					$arr = explode('=',$v);
					$opt[$arr[0]] = isset($arr[1]) ? rawurldecode($arr[1]) : 1;
				}
			} else {
				$opt = array();
			}
		}
	/*
	 *  phptype: Database backend used in PHP (mysql, odbc etc.)
	 *  dbsyntax: Database used with regards to SQL syntax etc.
	 *  protocol: Communication protocol to use (tcp, unix etc.)
	 *  hostspec: Host specification (hostname[:port])
	 *  database: Database to use on the DBMS server
	 *  username: User name for login
	 *  password: Password for login
	 */
		if (!empty($ADODB_NEWCONNECTION)) {
			$obj = $ADODB_NEWCONNECTION($db);

		}

		if(empty($obj)) {

			if (!isset($ADODB_LASTDB)) {
				$ADODB_LASTDB = '';
			}
			if (empty($db)) {
				$db = $ADODB_LASTDB;
			}
			if ($db != $ADODB_LASTDB) {
				$db = ADOLoadCode($db);
			}

			if (!$db) {
				if (isset($origdsn)) {
					$db = $origdsn;
				}
				if ($errorfn) {
					// raise an error
					$ignore = false;
					$errorfn('ADONewConnection', 'ADONewConnection', -998,
							"could not load the database driver for '$db'",
							$db,false,$ignore);
				} else {
					ADOConnection::outp( "<p>ADONewConnection: Unable to load database driver '$db'</p>",false);
				}
				return false;
			}

			$cls = 'ADODB_'.$db;
			if (!class_exists($cls)) {
				adodb_backtrace();
				return false;
			}

			$obj = new $cls();
		}

		# constructor should not fail
		if ($obj) {
			if ($errorfn) {
				$obj->raiseErrorFn = $errorfn;
			}
			if (isset($dsna)) {
				if (isset($dsna['port'])) {
					$obj->port = $dsna['port'];
				}
				foreach($opt as $k => $v) {
					switch(strtolower($k)) {
					case 'new':
										$nconnect = true; $persist = true; break;
					case 'persist':
					case 'persistent':	$persist = $v; break;
					case 'debug':		$obj->debug = (integer) $v; break;
					#ibase
					case 'role':		$obj->role = $v; break;
					case 'dialect':	$obj->dialect = (integer) $v; break;
					case 'charset':		$obj->charset = $v; $obj->charSet=$v; break;
					case 'buffers':		$obj->buffers = $v; break;
					case 'fetchmode':   $obj->SetFetchMode($v); break;
					#ado
					case 'charpage':	$obj->charPage = $v; break;
					#mysql, mysqli
					case 'clientflags': $obj->clientFlags = $v; break;
					#mysql, mysqli, postgres
					case 'port': $obj->port = $v; break;
					#mysqli
					case 'socket': $obj->socket = $v; break;
					#oci8
					case 'nls_date_format': $obj->NLS_DATE_FORMAT = $v; break;
					case 'cachesecs': $obj->cacheSecs = $v; break;
					case 'memcache':
						$varr = explode(':',$v);
						$vlen = sizeof($varr);
						if ($vlen == 0) {
							break;
						}
						$obj->memCache = true;
						$obj->memCacheHost = explode(',',$varr[0]);
						if ($vlen == 1) {
							break;
						}
						$obj->memCachePort = $varr[1];
						if ($vlen == 2) {
							break;
						}
						$obj->memCacheCompress = $varr[2] ?  true : false;
						break;
					}
				}
				if (empty($persist)) {
					$ok = $obj->Connect($dsna['host'], $dsna['user'], $dsna['pass'], $dsna['path']);
				} else if (empty($nconnect)) {
					$ok = $obj->PConnect($dsna['host'], $dsna['user'], $dsna['pass'], $dsna['path']);
				} else {
					$ok = $obj->NConnect($dsna['host'], $dsna['user'], $dsna['pass'], $dsna['path']);
				}

				if (!$ok) {
					return false;
				}
			}
		}

		$obj->setDataDictFromADONewConnection(NewDataDictionary($obj));
		return $obj;
	}



	// $perf == true means called by NewPerfMonitor(), otherwise for data dictionary
	function _adodb_getdriver($provider,$drivername,$perf=false) {
		switch ($provider) {
			case 'odbtp':
				if (strncmp('odbtp_',$drivername,6)==0) {
					return substr($drivername,6);
				}
			case 'odbc' :
				if (strncmp('odbc_',$drivername,5)==0) {
					$tTemp = substr($drivername,5);

					if($tTemp === "oracle")
						{return "oci8";}
					elseif($tTemp === "mssql2012")
						{return "mssql";}
					return $tTemp;
				}
			case 'ado'  :
				if (strncmp('ado_',$drivername,4)==0) {
					return substr($drivername,4);
				}
			case 'pdo' :
				if (strncmp('pdo_',$drivername,4)==0)
				{
					$tTemp = substr($drivername,4);

					switch($tTemp)
					{
						case "pgsql":
							return "postgres";
						case "oci":
							return "oci8";
						case "sqlsrv":
						case "dblib":
							return "mssql";
						case "sqlite":
						case "mysql":
						case "mssql":
						case "firebird":
							return $tTemp;
					}
				}
				return "generic";
			case 'db2' :
				if($drivername === "db2oci")
					{return 'oci8';}
				break;
			case 'mssqlnative':
				return 'mssql';
			case 'native':
				break;
			default:
				return $provider;
		}

		switch($drivername) {
			case 'mysqlt':
			case 'mysqli':
				$drivername='mysql';
				break;
			case 'postgres7':
			case 'postgres8':
			case 'postgres9':
				$drivername = 'postgres';
				break;
			case 'firebird15':
				$drivername = 'firebird';
				break;
			case 'oracle':
				$drivername = 'oci8';
				break;
			case 'access':
				if ($perf) {
					$drivername = '';
				}
				break;
			case 'sqlite2':
			case 'sqlite3':
				$drivername = 'sqlite';
				break;
			case 'db2'   :
			case 'db2legacy':
				$drivername = 'db2';
			case 'sapdb' :
				break;
			case 'borland_ibase':
				$drivername = 'ibase';
				break;
			case 'sybase_ase':
				$drivername = 'sybase';
				break;
			default:
				$drivername = 'generic';
				break;
		}
		return $drivername;
	}

	function NewPerfMonitor(&$conn) {
		$drivername = _adodb_getdriver($conn->dataProvider,$conn->databaseType,true);
		if (!$drivername || $drivername == 'generic') {
			return false;
		}
		include_once(ADODB_DIR.'/adodb-perf.inc.php');
		@include_once(ADODB_DIR."/perf/perf-$drivername.inc.php");
		$class = "Perf_$drivername";
		if (!class_exists($class)) {
			return false;
		}
		$perf = new $class($conn);

		return $perf;
	}

	function NewDataDictionary(&$conn,$drivername=false) {
		if (!$drivername) {
			$drivername = _adodb_getdriver($conn->dataProvider,$conn->databaseType);
		}

		include_once(ADODB_DIR.'/adodb-lib.inc.php');
		include_once(ADODB_DIR.'/adodb-datadict.inc.php');
		$path = ADODB_DIR."/datadict/datadict-$drivername.inc.php";

		if (!file_exists($path)) {
			ADOConnection::outp("Dictionary driver '$path' not available");
			return false;
		}
		include_once($path);
		$class = "ADODB2_$drivername";
		$dict = new $class();
		$dict->SetConnection($conn);
		$dict->upperName = strtoupper($drivername);

		return $dict;
	}



	/*
		Perform a print_r, with pre tags for better formatting.
	*/
	function adodb_pr($var,$as_string=false) {
		if ($as_string) {
			ob_start();
		}

		if (isset($_SERVER['HTTP_USER_AGENT'])) {
			echo " <pre>\n";print_r($var);echo "</pre>\n";
		} else {
			print_r($var);
		}

		if ($as_string) {
			$s = ob_get_contents();
			ob_end_clean();
			return $s;
		}
	}

	/*
		Perform a stack-crawl and pretty print it.

		@param printOrArr  Pass in a boolean to indicate print, or an $exception->trace array (assumes that print is true then).
		@param levels Number of levels to display
	*/
	function adodb_backtrace($printOrArr=true,$levels=9999,$ishtml=null) {
		global $ADODB_INCLUDED_LIB;
		if (empty($ADODB_INCLUDED_LIB)) {
			include_once(ADODB_DIR.'/adodb-lib.inc.php');
		}
		return _adodb_backtrace($printOrArr,$levels,0,$ishtml);
	}

}
